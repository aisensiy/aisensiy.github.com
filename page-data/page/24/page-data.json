{
    "componentChunkName": "component---src-templates-blogs-js",
    "path": "/page/24",
    "result": {"data":{"site":{"siteMetadata":{"title":"eisen-s-blog"}},"blogs":{"nodes":[{"id":"0d93902e-31ee-532d-901e-fff9200d80da","frontmatter":{"title":"Nodejs with babel es2015","date":"2016 September-21"},"html":"<p>最近开始尝试用 nodejs 去写后端 api，和前端类似，为了采用 es6 的语法同样需要做一些 boilerplate 的工作。这里记录下来，加深一下记忆。</p>\n<p>不过首先要先跑个题。其实 babel 不是第一个支持 js 变种的东西，最早出现过 coffeescript 目前比较流行的还有 typescript。typescript 支持强类型，支持 interface，尤其是 interface 这种 oo 的利器，真是让我跃跃欲试。但是有静静地想了想，其实目前 es6 作为一个未来的标准可能还是更有前途一些，并且目前的 es6 对于 oo 的支持已经相对来说好了一些了。应该还算凑合。</p>\n<h1 id=\"install-dependencies\" style=\"position:relative;\">Install Dependencies<a href=\"#install-dependencies\" aria-label=\"install dependencies permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>首先当然是创建项目，安装依赖了。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> init -y\n<span class=\"token function\">npm</span> i -D babel-cli babel-preset-es2015 nodemon</code></pre></div>\n<p>其中 <code>nodemon</code> 是用来检测项目下的文件自动重启 nodejs server 的。</p>\n<h1 id=\"create-babelrc\" style=\"position:relative;\">Create babelrc<a href=\"#create-babelrc\" aria-label=\"create babelrc permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>然后创建一个 <code>.babelrc</code> 文件表明所支持的 <code>babel</code> 内容。</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">touch</span> .babelrc</code></pre></div>\n<p>.babelrc:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  \"presets\": [\"es2015\"]\n}</code></pre></div>\n<p>如果想要支持 <code>Object Spread Operator</code> 这样的功能（就是 <code>...</code> 这个语法）则需要额外安装一个 babel 的插件 <code>babel-plugin-transform-object-rest-spread</code></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> babel-plugin-transform-object-rest-spread -D</code></pre></div>\n<p>然后在 <code>.babelrc</code> 添加如下内容</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  \"plugins\": [\"transform-object-rest-spread\"]\n}</code></pre></div>\n<h1 id=\"dev-command-to-run-es6-node-js\" style=\"position:relative;\">Dev command to run es6 node js<a href=\"#dev-command-to-run-es6-node-js\" aria-label=\"dev command to run es6 node js permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>在完成了 babel 的配置之后，我们就可以采用 es6 的语法去写 js 了。比如这里是一个样例。</p>\n<p><code>index.js</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> http <span class=\"token keyword\">from</span> <span class=\"token string\">'http'</span><span class=\"token punctuation\">;</span>\n\nhttp<span class=\"token punctuation\">.</span><span class=\"token function\">createServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  res<span class=\"token punctuation\">.</span><span class=\"token function\">writeHead</span><span class=\"token punctuation\">(</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token string\">'Content-Type'</span><span class=\"token operator\">:</span> <span class=\"token string\">'text/plain'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  res<span class=\"token punctuation\">.</span><span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello, World\\n\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">listen</span><span class=\"token punctuation\">(</span><span class=\"token number\">300</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'127.0.0.1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这里用到了 es6 的 <code>import</code> 以及 <code>=></code> 方法。如果直接执行 <code>node index.js</code> 是会报错的。这里我们可以在 <code>package.json</code> 中的 <code>scripts</code> 下添加一个方法 <code>dev</code> 用 <code>babel-node</code> 命令执行我们的 es6 语法的文件。</p>\n<p><code>package.json</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  \"script\": {\n    \"dev\": \"babel-node index.js\"\n  }\n}</code></pre></div>\n<p>然后通过用 <code>nodemon</code> 包裹 <code>dev</code> 命令可以做到自动重启 nodejs 的 server。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  \"script\": {\n    \"dev\": \"nodemon --exec babel-node index.js\"\n  }\n}</code></pre></div>\n<h1 id=\"build-command-to-create-code-for-production\" style=\"position:relative;\">Build command to create code for production<a href=\"#build-command-to-create-code-for-production\" aria-label=\"build command to create code for production permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p><code>babel-node</code> 仅仅是用于开发环境，每次修改代码后可以自动的编译文件。但是如果我们想要在生产环境部署代码的时候就需要一个专门的命令一次性将所有的代码编译成 <code>node</code> 支持的 es5 语法的文件了。</p>\n<p>这里我们在 <code>package.json</code> 中再增加一个 <code>build</code> 命令</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  \"script\": {\n    \"dev\": \"nodemon --exec babel-node index.js\",\n    \"build\": \"babel src --out-dir dist\"\n  }\n}</code></pre></div>\n<p>通过执行 <code>npm run build</code> 可以将 <code>src</code> 下的 <code>es6</code> 语法的文件编译成 <code>dist</code> 下支持 <code>es5</code> 语法的文件。</p>\n<p>最后在添加一个 <code>start</code> 方法去启动 <code>nodejs</code> server。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  \"script\": {\n    \"dev\": \"nodemon --exec babel-node index.js\",\n    \"build\": \"babel src --out-dir dist\",\n    \"start\" \"node dist/index.js\"\n  }\n}</code></pre></div>\n<p>为了保证每次执行 <code>npm run start</code> 命令前都会执行 <code>build</code> 命令，我们可以将 <code>build</code> 重命名为 <code>prestart</code>，<code>nodejs</code> 会自动的帮助我们在执行 <code>start</code> 之前执行它。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  \"script\": {\n    \"dev\": \"nodemon --exec babel-node index.js\",\n    \"prestart\": \"babel src --out-dir dist\",\n    \"start\" \"node dist/index.js\"\n  }\n}</code></pre></div>\n<h1 id=\"参考\" style=\"position:relative;\">参考<a href=\"#%E5%8F%82%E8%80%83\" aria-label=\"参考 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<ol>\n<li><a href=\"https://babeljs.io/docs/plugins/transform-object-rest-spread/\">Object Spread Operator</a></li>\n<li><a href=\"https://github.com/remy/nodemon\">nodemon</a></li>\n<li><a href=\"https://egghead.io/lessons/node-js-using-es6-and-beyond-with-node-js\">Using ES6 and beyond with Node.js - node Video Tutorial</a></li>\n</ol>","fields":{"slug_without_date":"/nodejs-with-babel-es2015"}},{"id":"9958f3dc-af13-5b1d-a620-73104b500de0","frontmatter":{"title":"Redux with react router update","date":"2016 August-17"},"html":"<p>之前有写过一篇 <a href=\"/redux-with-react-router\">Redux With React Router</a>，介绍 <code>redux</code> 与 <code>react-router</code> 结合实现多个视图的 WebApp，但是最近才发现有很多地方已经和之前使用的方式不一样了，这里做一个更新。</p>\n<h2 id=\"use-react-router-without-redux\" style=\"position:relative;\">use react-router without redux<a href=\"#use-react-router-without-redux\" aria-label=\"use react router without redux permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code>react-router</code> 提供了 <code>react</code> 的路由机制，在之前的文章中讲到了它可以和 <code>react-router-redux</code> 一起使用。当时的目的是为了将路由的信息传递到 <code>redux store</code> 中，在做 <code>container component</code> 的 <code>connect</code> 时可以通过 <code>mapStateToProps</code> 的方式将路由中的信息提供给组件使用。但是随着 <code>react-router</code> 的不断更新以及 <code>react-router-redux</code> 的定位的不断明确，现在可以不适用 <code>react-router-redux</code> 而仅仅用 <code>redux-router</code> 完成将路由绑定到 <code>container component</code>。而 <code>react-router-redux</code> 成为了追朔包含了路由的用户行为的一个工具，而这个功能对于很多应用来说不是很有必要，其官方文档也强调:</p>\n<blockquote>\n<p>This library is not necessary for using Redux together with React Router. You can use the two together just fine without any additional libraries. It is useful if you care about recording, persisting, and replaying user actions, using time travel. If you don't care about these features, just use Redux and React Router directly.</p>\n</blockquote>\n<h2 id=\"采用-withrouter-的高阶组件实现路由的绑定\" style=\"position:relative;\">采用 withRouter 的高阶组件实现路由的绑定<a href=\"#%E9%87%87%E7%94%A8-withrouter-%E7%9A%84%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E7%9A%84%E7%BB%91%E5%AE%9A\" aria-label=\"采用 withrouter 的高阶组件实现路由的绑定 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>首先，对于直接在 <code>Router</code> 中出现的组件，<code>react-router</code> 通过 <code>context</code> 的方式为该组件提供了当前路由的信息（如 <code>params</code> <code>location</code> 等）。但是如果是嵌套在路由创建的组件下的其他容器需要使用路由的信息呢？这个时候就需要用到 <code>withRouter</code> 这个由 <code>react-router</code> 提供的高阶组件了。在<a href=\"https://egghead.io/lessons/javascript-redux-using-withrouter-to-inject-the-params-into-connected-components\">这里</a> 由 <code>redux</code> 的作者提供了一个视频教程介绍了这个方法。可是如果你直接 <code>npm install react-router --save</code> 之后就按着作者的来使用的话会发现根本没有 <code>params</code> 的参数...原因在于 <code>withRouter</code> 这个高阶参数在当前默认的最新版 <code>react-router</code> 中根本没有提供这个东西，它仅仅注入了 <code>router</code> 方便组件做导航而已...只有明确的指定 <code>\"react-router\": \"^3.0.0-alpha.1\"</code> 的版本之后才能这么做...坑爹呀。</p>\n<h2 id=\"参考\" style=\"position:relative;\">参考<a href=\"#%E5%8F%82%E8%80%83\" aria-label=\"参考 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ol>\n<li><a href=\"https://egghead.io/lessons/javascript-redux-using-withrouter-to-inject-the-params-into-connected-components\">How to use withRouter</a></li>\n<li><a href=\"https://github.com/reactjs/react-router\">react-router</a></li>\n<li><a href=\"https://github.com/reactjs/react-router-tutorial\">react-router-tutorial</a></li>\n</ol>","fields":{"slug_without_date":"/redux-with-react-router-update"}},{"id":"9af50496-906e-5b91-9b14-93616ba4910b","frontmatter":{"title":"Learn wercker","date":"2016 June-02"},"html":"<p>半年来一直在做一个 PaaS 的项目，比较关注市面上的相关产品。最近发现一个叫做 wercker 的项目，感觉做的还不错，介绍一下。</p>\n<h2 id=\"wercker-要解决的问题\" style=\"position:relative;\">wercker 要解决的问题<a href=\"#wercker-%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98\" aria-label=\"wercker 要解决的问题 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>目前有很多的平台（如 mesos, rancher, kubernetes）都支持以 <code>docker image</code> 的形式进行应用的部署，但是却没有很多的工具帮助将 ci/cd 与这些平台进行更好的对接。而 wercker 的口号是 <code>From code to container</code>，强调自己可以做 ci/cd 的事情将代码转化为容器。那么之后就可以将这个容器作为交付的内容在需要的环境进行部署了。</p>\n<h2 id=\"wercker-的特性\" style=\"position:relative;\">wercker 的特性<a href=\"#wercker-%E7%9A%84%E7%89%B9%E6%80%A7\" aria-label=\"wercker 的特性 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ol>\n<li>\n<p>pipeline as cde</p>\n<p>wercker 提供一个类似于 <code>ansible</code> 的 <code>wercker.yml</code> 并提供与 <code>ansible</code> 类似的自定义命令来做部署的工作。</p>\n<p>自定义命令的功能非常的强大，种类也非常的丰富。例如 <code>npm-install</code> 安装 <code>node</code> 的依赖，<code>internal/docker-push</code> 将生成的 <code>image</code> 上传到 <code>docker registry</code>，<code>marathon-deploy</code> 将应用部署到 <code>marathon</code> 平台。</p>\n<p>整个 <code>pipeline</code> 可以通过这些命令拼装起来，所有的 pipeline 都可以通过一个 <code>wercker.yml</code> 文件进行管理。</p>\n</li>\n<li>\n<p>本地环境</p>\n<p>wercker 有一个命令行工具 <code>wercker-cli</code> 支持在本地通过 <code>docker</code> 和 <code>wercker-cli</code> 构建一个本地的开发环境，并且支持在本地环境提供 <code>backing service</code>。</p>\n</li>\n<li>\n<p>多 vendor 支持</p>\n<p>wercker 可以和多个 <code>PaaS</code> 对接的，包括 <code>heroku</code> <code>kubernetes</code> <code>marathon</code> <code>ecs</code> 等。这一点非常的难能可贵，想象一下，作为一个开发者，当有了类似于 <code>ecs</code> 或者 <code>heroku</code> 这样的公有云之后再配合 <code>wercker</code> 这样的工具可以快速的搭建 <code>pipeline</code> 以及完成以前需要花费更多时间才能得到的 <code>ci/cd</code> 开发效率真是大大的提升。</p>\n</li>\n<li>\n<p>ui 界面</p>\n<p>提供一个 ui 界面管理整个 pipeline</p>\n</li>\n<li>\n<p>与 github &#x26; bitbucket 对接</p>\n<p>支持 github bitbucket hook，在有新的 commit 之后自动构建、部署。\n管理关键数据，有些数据不适合存放在 <code>wercker.yml</code> 中，例如 <code>heroku</code> 的 <code>accesskey</code>，<code>docker-hub</code> 的账号密码。</p>\n</li>\n</ol>\n<h2 id=\"参考\" style=\"position:relative;\">参考<a href=\"#%E5%8F%82%E8%80%83\" aria-label=\"参考 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><a href=\"https://wercker.com\">wercker</a></p>","fields":{"slug_without_date":"/learn-wercker"}}],"pageInfo":{"hasPreviousPage":true,"currentPage":24,"pageCount":44}}},"pageContext":{"limit":3,"skip":69}},
    "staticQueryHashes": []}