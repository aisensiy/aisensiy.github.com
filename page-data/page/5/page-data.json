{
    "componentChunkName": "component---src-templates-blogs-js",
    "path": "/page/5",
    "result": {"data":{"site":{"siteMetadata":{"title":"eisen-s-blog"}},"blogs":{"nodes":[{"id":"ab7349fa-d565-51c5-8f7f-0890065a2f93","frontmatter":{"title":"处理 k8s 证书过期","date":"2022 January-18"},"html":"<h2 id=\"简单记录\" style=\"position:relative;\">简单记录<a href=\"#%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95\" aria-label=\"简单记录 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>k8s 为了鼓励大家更新，其 kubeadm 默认的证书有效期为 1 年，任何 k8s 版本的更新都会触发证书的更新。如果证书过期了可以按照如下方式处理：</p>\n<ol>\n<li>如果发现自己本地 kubectl 无法访问集群并报错就很有可能是证书过期了，登陆任意一台 master 执行命令 <code>kubeadm certs check-expiration</code> 可以查看证书的有效期，如果报错没有命令 <code>certs</code> 那么可以尝试命令 <code>kubeadm alpha certs ...</code></li>\n<li>过期后可以用命令 <code>kubeadm certs renew all</code> 更新所有证书</li>\n<li>更新后需要将 <code>/etc/kubernetes/manifests/</code> 挪走，比如重命名为 <code>manifests.1</code> 20 秒以上，等待 static pod 全部都关闭了，然后重命名回来，这个步骤就是强迫所有的 static pod 重启，<a href=\"https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#manual-certificate-renewal\">官网文档</a> 就是这么建议操作的</li>\n<li>如果是 HA 高可用模式，那么需要将每一台 master 都这么操作一下</li>\n<li>将新的 <code>/etc/kubernetes/admin.conf</code> 拷贝到自己的电脑，并将其其中的 api-server 的访问地址修改成从自己电脑可以访问的地址即可，然后具体的管理可以参考 <a href=\"/kubeconfig-management\">维护一大堆 kubeconfig 的一些实践</a></li>\n</ol>\n<h2 id=\"更好的办法\" style=\"position:relative;\">更好的办法<a href=\"#%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%8A%9E%E6%B3%95\" aria-label=\"更好的办法 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>这样做现在并不是最好的方法，目前可以改进的方式有如下几个：</p>\n<ol>\n<li>按照官方推荐，更频繁的升级 k8s 避免自己的集群版本掉队到无法维护，这应该是最好的方法，当然听起来成本也高一些</li>\n<li>简单粗暴，修改对应版本的 kubeadm 源码，将 renew 时间改成什么 100 年之类的，然后用这个编译的版本去 renew 就是 100 年有效期了</li>\n<li><a href=\"https://github.com/fanux/sealos\">https://github.com/fanux/sealos</a> <strong>可能是不错的方案，具体还没看</strong></li>\n</ol>\n<h2 id=\"资料\" style=\"position:relative;\">资料<a href=\"#%E8%B5%84%E6%96%99\" aria-label=\"资料 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ol>\n<li><a href=\"https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/\">Certificate Management with kubeadm</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1650657\">kubeadm 集群修改证书时间到 99 年</a></li>\n</ol>","fields":{"slug_without_date":"/kubernetes-certs-renew"}},{"id":"3e518264-2cde-5b53-bd2c-cff578eb64da","frontmatter":{"title":"使用 ansible 为 ubuntu 设置代理","date":"2021 December-30"},"html":"<p>最近为一些藏在防火墙里的存储节点做 provision 由于是非常受限的外网访问，必须要通过代理访问网络，因此需要对原来的 ansible 脚本做修改，这里做一个记录。</p>\n<p>看了看 ansible 里面的内容以及后续的 k8s 的流程，无非是如下几个方面需要访问外网：</p>\n<ol>\n<li>curl 一些 github 上的一些公钥</li>\n<li>apt install</li>\n<li>k8s 拉镜像</li>\n</ol>\n<p>那么，对应的就是以下三个方面的代理配置：</p>\n<ol>\n<li>http_proxy / https_proxy 环境变量配置</li>\n<li>apt 不走环境变量的代理，需要单独配置下</li>\n<li>我这里依然使用的 docker 拉镜像的时候也要做独立的配置，不过在一篇 <a href=\"/docker-accelerate\">旧文- 国内环境下更好的 docker 镜像获取</a> 已经介绍过了</li>\n</ol>\n<h2 id=\"设置全局环境变量\" style=\"position:relative;\">设置全局环境变量<a href=\"#%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\" aria-label=\"设置全局环境变量 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>根据 ansible 的文档 <a href=\"https://docs.ansible.com/ansible/latest/user_guide/playbooks_environment.html\">Setting remote env</a> ansible 提供了 <code>environment</code> 的关键词，可以在 <code>task</code> <code>play</code> 等不同层级添加环境变量：</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">-</span> <span class=\"token key atrule\">hosts</span><span class=\"token punctuation\">:</span> all\n  <span class=\"token key atrule\">remote_user</span><span class=\"token punctuation\">:</span> root\n\n  <span class=\"token key atrule\">tasks</span><span class=\"token punctuation\">:</span>\n\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Install cobbler\n      <span class=\"token key atrule\">ansible.builtin.package</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> cobbler\n        <span class=\"token key atrule\">state</span><span class=\"token punctuation\">:</span> present\n      <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">http_proxy</span><span class=\"token punctuation\">:</span> http<span class=\"token punctuation\">:</span>//proxy.example.com<span class=\"token punctuation\">:</span><span class=\"token number\">8080</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">-</span> <span class=\"token key atrule\">hosts</span><span class=\"token punctuation\">:</span> testing\n\n  <span class=\"token key atrule\">roles</span><span class=\"token punctuation\">:</span>\n     <span class=\"token punctuation\">-</span> php\n     <span class=\"token punctuation\">-</span> nginx\n\n  <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">http_proxy</span><span class=\"token punctuation\">:</span> http<span class=\"token punctuation\">:</span>//proxy.example.com<span class=\"token punctuation\">:</span><span class=\"token number\">8080</span></code></pre></div>\n<p>当然，我们这里就没什么外网，那自然就走一个全局的。</p>\n<h2 id=\"添加-apt-的-proxy-配置\" style=\"position:relative;\">添加 apt 的 proxy 配置<a href=\"#%E6%B7%BB%E5%8A%A0-apt-%E7%9A%84-proxy-%E9%85%8D%E7%BD%AE\" aria-label=\"添加 apt 的 proxy 配置 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>apt 的 proxy 需要放到 <code>/etc/apt/apt.conf.d</code> 下，格式如下:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Acuire::http { Proxy \"http://proxy:1234\" }\nAcuire::https { Proxy \"http://proxy:1234\" }</code></pre></div>\n<p>写成一个 ansible task 就是下面这个样子：</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> add proxy for apt\n  <span class=\"token key atrule\">copy</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">dest</span><span class=\"token punctuation\">:</span> /etc/apt/apt.conf.d/02proxy\n    <span class=\"token key atrule\">content</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n      Acquire::http { Proxy \"{{ http_proxy }}\" }\n      Acquire::https { Proxy \"{{ https_proxy }}\" }</span></code></pre></div>\n<p>其中 <code>http_proxy</code> 和 <code>https_proxy</code> 抽出来做为变量后面填写进来。</p>\n<h2 id=\"添加-docker-的-proxy\" style=\"position:relative;\">添加 docker 的 proxy<a href=\"#%E6%B7%BB%E5%8A%A0-docker-%E7%9A%84-proxy\" aria-label=\"添加 docker 的 proxy permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>在上面提到的旧闻中讲过了，启动 docker 的时候需要配置环境变量，放到 systemd 的配置 <code>/etc/systemd/system/docker.service.d/http-proxy.conf</code> 中：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[Service]\nEnvironment=\"HTTP_PROXY=http://proxy:1234\"\nEnvironment=\"HTTPS_PROXY=http://proxy:1234\"</code></pre></div>\n<p>然后需要执行命令 <code>systemctl daemon-reload</code>。</p>\n<h2 id=\"放在一起\" style=\"position:relative;\">放在一起<a href=\"#%E6%94%BE%E5%9C%A8%E4%B8%80%E8%B5%B7\" aria-label=\"放在一起 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>放在一起差不多就是这个样子：</p>\n<p><code>roles/proxy/tasks/main.yml</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">---</span>\n<span class=\"token punctuation\">-</span> <span class=\"token key atrule\">file</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">dest</span><span class=\"token punctuation\">:</span> /etc/systemd/system/docker.service.d\n    <span class=\"token key atrule\">state</span><span class=\"token punctuation\">:</span> directory\n<span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> add docker proxy settings\n  <span class=\"token key atrule\">copy</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">directory_mode</span><span class=\"token punctuation\">:</span> yes\n    <span class=\"token key atrule\">dest</span><span class=\"token punctuation\">:</span> /etc/systemd/system/docker.service.d/http<span class=\"token punctuation\">-</span>proxy.conf\n    <span class=\"token key atrule\">content</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n      [Service]\n      Environment=\"HTTP_PROXY={{ http_proxy }}\"\n      Environment=\"HTTPS_PROXY={{ https_proxy }}\"</span>\n<span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> reload docker\n  <span class=\"token key atrule\">service</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> docker\n    <span class=\"token key atrule\">state</span><span class=\"token punctuation\">:</span> restarted\n    <span class=\"token key atrule\">daemon_reload</span><span class=\"token punctuation\">:</span> yes\n<span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> add proxy for apt\n  <span class=\"token key atrule\">copy</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">dest</span><span class=\"token punctuation\">:</span> /etc/apt/apt.conf.d/02proxy\n    <span class=\"token key atrule\">content</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n      Acquire::http { Proxy \"{{ http_proxy }}\" }\n      Acquire::https { Proxy \"{{ https_proxy }}\" }</span></code></pre></div>\n<p><code>entry.yml</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml\"><pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">---</span>\n<span class=\"token punctuation\">-</span> <span class=\"token key atrule\">hosts</span><span class=\"token punctuation\">:</span> nodes\n  <span class=\"token key atrule\">vars</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">http_proxy</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"http://proxy:7890\"</span>\n    <span class=\"token key atrule\">https_proxy</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"http://proxy:7890\"</span>\n  <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">http_proxy</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"http://proxy:7890\"</span>\n    <span class=\"token key atrule\">https_proxy</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"http://proxy:7890\"</span>\n  <span class=\"token key atrule\">roles</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">role</span><span class=\"token punctuation\">:</span> proxy</code></pre></div>\n<h2 id=\"更好的方案\" style=\"position:relative;\">更好的方案<a href=\"#%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%A1%88\" aria-label=\"更好的方案 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>有没有更好的方案？我觉得有，就是用 <a href=\"https://github.com/xjasonlyu/tun2socks/\">tun2socks</a> 的方案，可以实现以上三个方面的代理设置。不过还没很仔细的折腾，等搞定了再做记录。</p>","fields":{"slug_without_date":"/proxy-setup-for-ubuntu-with-ansible"}},{"id":"eac27307-a5b7-54b4-9ea3-26d65f7cd1e7","frontmatter":{"title":"spring boot 整理 SpringBootApplication","date":"2021 December-23"},"html":"<p>早在 2017 年有写过一些 spring boot 测试相关的内容，比如 <a href=\"/spring-mvc-and-test\">在 Spring Boot 1.5.3 中进行 Spring MVC 测试</a>，再比如 <a href=\"/spring-mvc-and-mybatis\">把 Spring Boot 1.5.3 与 MyBatis 集成</a>。现在都 2021 年马上 2022 年了，spring boot 的最新版本已经来到了 2.6，其所依赖的一系列东西也发生了不少变化。同时随着我们项目变得越来越大，测试用例越来越多，对测试的性能、标准化的要求也越来越迫切。从这篇开始记录一些自己最近翻看 spring test 以及 spring boot test 了解到的有关 spring 测试体系的内容。</p>\n<p>spring 以及 spring boot 测试相关的内容简单 google 一下就能看到很多，但我个人感觉非常不成体系，这个应该也和 spring 不断的更迭关系很大，很多新旧知识掺杂在一起，有点摸不清楚。这里我参考的核心资料是如下两个：</p>\n<ol>\n<li><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/testing.html\">Spring Testing</a></li>\n<li><a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing\">Spring Boot Testing</a></li>\n</ol>\n<p>翻看了这两部分内容后感觉 Spring 的文档写的还是比较全面的，不过很遗憾 Spring Testing 的内容写的还是不够细致，可能需要自己去结合源码和其他资料才能更好的消化吸收。但我觉得确实比直接在其他地方要系统一些。</p>\n<p>今天先介绍最近消化的第一个 Tips 什么不应该放进 <code>@SpringBootApplication</code>。</p>\n<h2 id=\"springbootapplication-简单介绍\" style=\"position:relative;\">@SpringBootApplication 简单介绍<a href=\"#springbootapplication-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D\" aria-label=\"springbootapplication 简单介绍 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code>@SpringBootApplication</code> 是一个集成注解，翻看源码可以看到它包含了额外三个注解：</p>\n<ul>\n<li><code>@SpringBootConfiguration</code>: 作为 SpringBoot 默认的 Configuration Class</li>\n<li><code>@EnableAutoConfiguration</code>: 允许 Auto Configuration</li>\n<li><code>@ComponentScan</code>: 支持 Component Scan 的方式提供各种 <code>Bean</code></li>\n</ul>\n<p>添加这个注解的 Class 也通常就是整个应用的入口了。在这里可能会放一些全局初始化的东西，不过根据 Spring Boot Testing 的 <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.spring-boot-applications.user-configuration-and-slicing\">User Configuration and Slicing</a> 介绍，这里反而不是那种什么都可以放的地方，随便放各种东西会影响你的测试依赖。</p>\n<h2 id=\"为什么-springbootapplication-不能添加各种依赖\" style=\"position:relative;\">为什么 SpringBootApplication 不能添加各种依赖<a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-springbootapplication-%E4%B8%8D%E8%83%BD%E6%B7%BB%E5%8A%A0%E5%90%84%E7%A7%8D%E4%BE%9D%E8%B5%96\" aria-label=\"为什么 springbootapplication 不能添加各种依赖 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>这样从 Spring Boot 写测试通常使用的 <code>@SpringBootTest</code> 和 <code>@WebMvcTest</code> 注解的行为做解释了。</p>\n<p>通常来说，如果我们的依赖链条都是靠我们自己去切断，不依赖 Spring 的 ApplicationContext 那么这种测试就算是 Unit Test 。反之任何需要依赖 ApplicationContext 的都可以称为 Integration Test。面向 WebMvc 或者需要和数据库接触的测试都需要 ApplicationContext 而这个 ApplicationContext 如何建立就是靠的 <code>@SpringBootTest</code> 或者 <code>@WebMvcTest</code> 这样的注解了。</p>\n<p>标记 <code>@SpringBootTest</code> 或者其他 Spring Boot 提供的 <code>@*Test</code> 注解的测试会尝试寻找从根目录开始寻找标记了 <code>@SpringBootApplication</code> 或者 <code>@SpringBootConfiguration</code> 的类，并以它为起点加载完整的 ApplicationContext 。在 Spring Boot 的 <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.spring-boot-applications.detecting-configuration\">Detecting Test Configuration</a> 文档里也做了说明：</p>\n<blockquote>\n<p>When testing Spring Boot applications, this is often not required. Spring Boot’s @Test annotations search for your primary configuration automatically whenever you do not explicitly define one.</p>\n<p>The search algorithm works up from the package that contains the test until it finds a class annotated with @SpringBootApplication or @SpringBootConfiguration. As long as you structured your code in a sensible way, your main configuration is usually found.</p>\n</blockquote>\n<p>当然也可以通过增加 <code>classes</code> 参数 explicitly define 一个 Configuration 修改其默认搜索的行为：</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@SpringBootTest</span><span class=\"token punctuation\">(</span>classes <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token class-name\">GraphQLTestConfiguration</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">DgsAutoConfiguration</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Import</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CustomDataFetchingExceptionHandler</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@RunWith</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">SpringRunner</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">abstract</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GraphQLTestBase</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">TestBase</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"应该如何修改\" style=\"position:relative;\">应该如何修改<a href=\"#%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9\" aria-label=\"应该如何修改 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>在文档的 <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.spring-boot-applications.user-configuration-and-slicing\">User Configuration and Slicing</a> 部分有做介绍：</p>\n<blockquote>\n<p>Test slices exclude @Configuration classes from scanning.</p>\n</blockquote>\n<p>但是 <code>@SpringBootApplication</code> 默认的 <code>@ComponentScan</code> 可不会跳过任何 <code>@Configuration</code> 因此，为了让全局的依赖注入不要污染不必要的 <code>Test Slices</code> 可以把额外的依赖注入放在单独的 <code>@Configuration</code> 下，这里我直接超文档的内容：</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@SpringBootApplication</span>\n<span class=\"token annotation punctuation\">@EnableBatchProcessing</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyApplication</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">// ...</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>修改为</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Configuration</span><span class=\"token punctuation\">(</span>proxyBeanMethods <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@EnableBatchProcessing</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyBatchConfiguration</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">// ...</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"总结\" style=\"position:relative;\">总结<a href=\"#%E6%80%BB%E7%BB%93\" aria-label=\"总结 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ol>\n<li><code>@SpringBootApplication</code> 自带 <code>ComponentScan</code> 会收集自己 package 下所有的 Beans 和 Configurations</li>\n<li>Spring Boot 提供的 <code>@*Test</code> 会自己搜索 <code>@SpringBootApplication</code> 或者 <code>@SpringBootConfiguration</code> 作为默认的 <code>Configuration</code>，除非你主动做覆盖</li>\n<li>为了让 2 的行为不要导致过量的 <code>ApplicationContext</code> 在测试阶段被创建，可以把一些只有在生成环境才需要的额外的 Bean 放在独立的 <code>@Configuration</code> 类下，因为 Spring Boot 的 Testing slices 不会扫其他的 <code>@Configuration</code></li>\n</ol>","fields":{"slug_without_date":"/spring-boot-test"}}],"pageInfo":{"hasPreviousPage":true,"currentPage":5,"pageCount":45}}},"pageContext":{"limit":3,"skip":12}},
    "staticQueryHashes": []}