{"componentChunkName":"component---src-templates-blogs-js","path":"/page/13","result":{"data":{"blogs":{"nodes":[{"id":"899b6565-2be7-5b8e-a295-1d576ad8729d","frontmatter":{"title":"Webpack Setup","date":"2016 May-05"},"html":"<p>虽然用 <code class=\"language-text\">webpack</code> 有一阵子了，但是上次构建整个体系的时候手忙脚乱的，仅仅是找了乱七八糟的东西堆叠起来，中间的过程忘的一干二净今天去 review 自己以前写的代码完全不知道自己是怎么搞定的。这次写一个小系列把如何构建 <code class=\"language-text\">webpack</code> + <code class=\"language-text\">redux</code> + <code class=\"language-text\">react</code> 的体系记下来，今天是第一部分，<code class=\"language-text\">webpack</code> 的准备工作。</p>\n<p><code class=\"language-text\">webpack</code> 可以认为就是一个 <code class=\"language-text\">node</code> 版本的 <code class=\"language-text\">make</code> 吧，不过自然是有 <code class=\"language-text\">js</code> 特色的 <code class=\"language-text\">make</code> 了，类似的东西有很多，比如 <code class=\"language-text\">browserify</code> 以及 <code class=\"language-text\">gulp</code> 等。<code class=\"language-text\">webpack</code> 最终的目的就是将我们一个有众多文件的 <code class=\"language-text\">js</code> 的 project 变成只有一个或者多个文件的 <code class=\"language-text\">bundles</code>，我在后面会结合例子做展示。并且<code class=\"language-text\">webpack</code> 可以支持 <code class=\"language-text\">loader</code> 将各种诡异的 <code class=\"language-text\">js</code> 方言转换成 <code class=\"language-text\">js</code> 比如当下比较流行的额 <code class=\"language-text\">babel</code> <code class=\"language-text\">jsx</code> 等，所以 <code class=\"language-text\">webpack</code> 配合 <code class=\"language-text\">es2015</code> 以及 <code class=\"language-text\">react</code> 一起使用非常的方便。不过要说明的是对这些方言的支持是 <code class=\"language-text\">loader</code> 的事情，<code class=\"language-text\">webpack</code> 本身是只能处理原生态的 <code class=\"language-text\">js</code> 的。</p>\n<h2 id=\"basic\" style=\"position:relative;\">basic<a href=\"#basic\" aria-label=\"basic permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>首先自然是安装 <code class=\"language-text\">webpack</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">npm install -g webpack\nnpm install -S webpack</code></pre></div>\n<p>然后我展示一个 <code class=\"language-text\">webpack</code> 的基本用法。首先看一下我们的目录结构：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">├── index.html\n├── index.js\n├── module1.js\n├── module2.js\n└── package.json</code></pre></div>\n<p>其中 <code class=\"language-text\">index.html</code> 基本就是一个空文件</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;html>\n  &lt;head>\n    &lt;meta charset=\"utf-8\">\n    &lt;title>index&lt;/title>\n  &lt;/head>\n  &lt;body>\n    &lt;script src=\"bundle.js\">&lt;/script>\n  &lt;/body>\n&lt;/html></code></pre></div>\n<p><code class=\"language-text\">module1.js</code> <code class=\"language-text\">module2.js</code> 展示如下</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log('module 1');</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(\"module 2\");</code></pre></div>\n<p><code class=\"language-text\">index.js</code> 通过 <code class=\"language-text\">require</code> 的方式引用两个模块</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">require(\"./module1\");\nrequire(\"./module2\");</code></pre></div>\n<p>然后通过命令 <code class=\"language-text\">webpack ./index.js bundle.js</code> 可以将 <code class=\"language-text\">index.js</code> 以及其所依赖的模块打包生成一个文件 <code class=\"language-text\">bundle.js</code> 这样在浏览器打开 <code class=\"language-text\">index.html</code> 就可以看到 <code class=\"language-text\">console</code> 中的命令了。</p>\n<h2 id=\"use-webpackconfigjs\" style=\"position:relative;\">use webpack.config.js<a href=\"#use-webpackconfigjs\" aria-label=\"use webpackconfigjs permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>在上述这么简单的情况下我们就仅仅用 <code class=\"language-text\">webpack</code> 的命令就可以了。不过在处理更复杂的事情的时候需要 <code class=\"language-text\">webpack.config.js</code> 来帮忙。这里我给出一个最小化的 <code class=\"language-text\">webpack.config.js</code> 的实例来替代刚才的命令。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var path = require(\"path\");\n\nmodule.exports = {\n  entry: [\n    './index'\n  ],\n  output: {\n    path: path.join(__dirname, \"dist\"),\n    filename: \"bundle.js\"\n  }\n};</code></pre></div>\n<p>其中，<code class=\"language-text\">entry</code> 就是我们整个 <code class=\"language-text\">project</code> 的 <code class=\"language-text\">main</code>。就如在前文中 <code class=\"language-text\">webpack ./index.js bundle.js</code> 的 <code class=\"language-text\">./index.js</code> 的角色。<code class=\"language-text\">output</code> 则表示我们要将生成的 <code class=\"language-text\">js</code> 放在哪里。这里我提供了一个不同的 <code class=\"language-text\">path</code>: <code class=\"language-text\">dist</code>，然后依然采用 <code class=\"language-text\">bundle.js</code> 的名字。这样我们执行 <code class=\"language-text\">webpack</code> 就可以看到 <code class=\"language-text\">dist</code> 下出现了 <code class=\"language-text\">bundle.js</code> 这个文件。</p>\n<h2 id=\"use-webpack-dev-server\" style=\"position:relative;\">use webpack dev server<a href=\"#use-webpack-dev-server\" aria-label=\"use webpack dev server permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>那么每次改了文件之后都 <code class=\"language-text\">webpack</code> 是不是很麻烦，应该是有 <code class=\"language-text\">watch</code> 的办法吧。对的，这就是 <code class=\"language-text\">webpack-dev-server</code> 了。首先安装它。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">npm install -g webpack-dev-server\nnpm install -S webpack-dev-server</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">执行 `webpack-dev-server --inline --hot --content-base dist/`，每次修改代码就可以自动 build 了。</code></pre></div>\n<p>既然这里我们把 <code class=\"language-text\">content-base</code> 设定为了 <code class=\"language-text\">dist</code> 那么需要把 <code class=\"language-text\">index.html</code> 放进去啦。最后的目录结构是这样子的：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">├── dist\n│   ├── bundle.js\n│   └── index.html\n├── index.js\n├── module1.js\n├── module2.js\n├── package.json\n└── webpack.config.js</code></pre></div>\n<p>值得一提是在 <code class=\"language-text\">package.json</code> 里有一个专门放置这种启动 server 的地方，就是在 <code class=\"language-text\">scripts</code> 下:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  \"name\": \"webpack-setup\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"webpack\": \"^1.13.0\"\n  }\n}</code></pre></div>\n<p>然后下次执行 <code class=\"language-text\">npm start</code> 就可以启动这个 dev server 啦。</p>\n<h2 id=\"一些参考\" style=\"position:relative;\">一些参考<a href=\"#%E4%B8%80%E4%BA%9B%E5%8F%82%E8%80%83\" aria-label=\"一些参考 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ol>\n<li>webpack.config.js <a href=\"http://webpack.github.io/docs/configuration.html\">http://webpack.github.io/docs/configuration.html</a></li>\n<li>webpack dev server <a href=\"http://webpack.github.io/docs/webpack-dev-server.html\">http://webpack.github.io/docs/webpack-dev-server.html</a></li>\n</ol>","fields":{"slug_without_date":"/webpack-setup"}},{"id":"9ae10e2a-5c45-5b23-9ab6-815122790251","frontmatter":{"title":"Some tips about DDD","date":"2016 April-20"},"html":"<p>DDD 即 Domain Driven Design, 领域驱动设计，似乎是一个比较老的东西了，2003 年这本书就出版了。不过这么多年来我是从来都没有知晓过，直到参加了小巨人的培训。在培训的过程中，我自己尝试自己对某个领域进行建模并且以 REST API 的形式实现自己的设计，而整个过程中都要尽量的遵循 DDD 的一些设计原则，可惜培训时间太短了，我需要更多的时间去消化。半年多来我一直都在琢磨这个主题，即使工作任务很重的时候我依然在尝试把以前自己认为不遵循 DDD 设计的一些项目按照我理解的 DDD （对，我理解的，不代表是对的）进行了重写，这虽然花了不少的时间但我认为这是值得的。其中经常出现的几个名词 <code class=\"language-text\">aggregate</code> <code class=\"language-text\">value object</code> <code class=\"language-text\">entity</code> <code class=\"language-text\">bounded context</code> <code class=\"language-text\">domain model</code> <code class=\"language-text\">repository</code> <code class=\"language-text\">factory</code> 一直以来我总觉得自己没有把它们彻底的搞明白。整个体系对我来说依然没有在我的脑海中建立起来。直到最近，在认认真真的看完了几本 DDD 主题的书籍以及众多有关这个主题的文章和演讲之后，我才觉得我对这方面的理解有了起色，我逐渐的弄明白了 DDD 的真正意图，清楚了 REST 和 DDD 的关系，我才敢写下这篇文章。</p>\n<p>培训中 REST 和 DDD 的主题是被放在一起讲解的，REST 按照 DDD 中 <code class=\"language-text\">aggregate</code> 的形式被组织在一起。看下面这样一组 REST API:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/users\n/users/:user-id\n/users/:user-id/orders\n/users/:user-id/orders/:order-id</code></pre></div>\n<p><code class=\"language-text\">user</code> 作为一个 <code class=\"language-text\">aggregate</code> 的 <code class=\"language-text\">root</code>，它包含了其下所有的 <code class=\"language-text\">order</code>。这样最初看起来没什么不妥，<code class=\"language-text\">order</code> 是随着 <code class=\"language-text\">user</code> 出现的，<code class=\"language-text\">order</code> 的生命周期是受 <code class=\"language-text\">user</code> 控制的。这就像是 Evans 在第六章节举的那个例子，<code class=\"language-text\">line item</code> 是 <code class=\"language-text\">order</code> 的一部分。但是在实现这部分 api 的时候我发现我有一点是难以做到的：<code class=\"language-text\">order</code> 是不能够随着 <code class=\"language-text\">user</code> 一起载入到内存的，它不像是 <code class=\"language-text\">order</code> 与 <code class=\"language-text\">order line item</code> 那样的关系。user's orders 这个集合是可以不断的扩张的，我甚至不能把一个用户所有的 order 一次性的载入到内存中，我需要分页，我需要根据默写规则对用户的订单进行筛选。此时再仔细想想 DDD 的那个例子，里面涉及了很多的并发冲突，然而当我需要拿到用户以及查询订单的时候会有什么呢？没有，什么冲突都不会发生。逐渐的我才明白其实我一开始就理解错了。事实上，<strong>DDD 关注的是一个写模型</strong>，并发的冲突都是在有写操作的时候才会出现。例子中的创建和修改订单都是写，而我所要考虑的仅仅是读而已，读事实上什么麻烦都不会产生，怎么读都不会产生问题。</p>\n<p>再去看看 Implementing DDD 这本书的例子，<code class=\"language-text\">application</code> 这个 package 被分成了两部分，一部分是 <code class=\"language-text\">Query</code> 一部分是 <code class=\"language-text\">Command</code>，没错就是 CQRS 的思路。一个个 <code class=\"language-text\">Command</code> 调用了 <code class=\"language-text\">domain</code> 中的对象和方法，实现了关键的业务。而 <code class=\"language-text\">Query</code> 的 Data Model 和 Domain Model 有质的区别，Query Service 甚至是直接拼装了 HQL (Hibernate SQL)。它更多的是面向 UI 的：需要展示什么就提供什么。那么这样来看，很多事情就迎刃而解了。</p>\n<p>简单的来讲，aggregate 就是为了解决一个并发的问题。aggregate 就是定义了一个业务场景中最小的锁单元：任何人对一个 aggregate 操作时其他人都不能再对这个单元进行操作了。而整个业务中数据的一致性也是由这样的方式得到了保证。那么回到上面的例子，<code class=\"language-text\">user</code> 下的 <code class=\"language-text\">order</code> 是没有道理和 <code class=\"language-text\">user</code> 建立为一个 <code class=\"language-text\">aggregate</code> 的。<code class=\"language-text\">user</code> 和 <code class=\"language-text\">order</code> 分别是一个单 <code class=\"language-text\">entity</code> 的 <code class=\"language-text\">aggregte</code>。</p>\n<p>DDD 仅仅是一个写模型。在通过 REST API 暴露一个 Domain 的接口的时候要明确每一个方法分别对应了相应资源下的什么操作。虽然很多的数据和演讲中强调 REST 和 DDD 没关系，并且 Rest 的 Resource 也和 DDD 中的 Entity 没有映射关系，但是我个人觉得从 UL 的角度来说，外部所看到的东西和 Domain 所提及的东西应当一致，只是 REST 会隐藏很多细节罢了。当然，这里所谓的隐藏细节也可能隐藏的多到内外的概念是不一致的。其中 <code class=\"language-text\">GET</code> 和其他操作相比有着质的区别，它可能采用了纯粹的 DTO 而不涉及任何的 Domain，这样在实现模型的时候我们就不必小心翼翼的去让 Domain Model 尽量的和 Rest 所需要获取的数据保持一致了。这也是我自己在整个过程中最困惑的地方了。</p>\n<p>到这里，按照 DDD 设计的思路就清楚多了，我不再担心如何让 GET 方法从 Domain 中拿到它想要的东西了。我可以在设计的时候首先关注更重要的业务流程，然后在需要的时候用最简单的方式提供相应的 Query Service 即可。</p>","fields":{"slug_without_date":"/some-tips-for-ddd"}},{"id":"1452c4ec-c23f-57aa-bc28-cd2cffb5a47e","frontmatter":{"title":"新的博客","date":"2016 March-26"},"html":"<p>之前的 blog 是搭在 SAE 的 wordpress，但是由于渣浪没有回复我的账号，我默默的看着我的 SAE 云豆消耗殆尽连个充值的机会都没有，真是不知道新浪这样的状态还能撑多久。不过不管怎么样我应该还是有机会可以把我的博客拿到的，然后赶紧的把乱七八糟的博客都导过来，毕竟那个博客也用了有 5 年了吧。</p>\n<p>之前有尝试用 jekyll 在 github 上部署 blog，那个时候 github 对 jekyll 的支持还没有那么好，我记得是不能够自己主动的部署到 xx.github.io 上的，需要自己拉一个 branch 但是现在似乎不需要了，默认部署，方便多了。而且之前的那个默认的 template 也是太丑了，自己也没有当初调整 wordpress template 的心情了哎（所以我自己对我以前 wordpress 的 template 还是挺满意的，毕竟人家默认的 template 就不错呀）。幸好找到了现在 <a href=\"huangxuan.me\">hux</a> 这套给力的模板，我又有动力用 jekyll 了。好多地方还是人家 hux 的名字，我也在慢慢修改了。</p>\n<p>github 首先应该不会在短期内挂掉吧，然后人家也是给了我一个域名，唯一一点不好就是有些 2b 的学校教育网默认不能访问国外的服务器，这我就没有办法了。</p>","fields":{"slug_without_date":"/new-blog"}},{"id":"168a8b80-a331-5f56-ab2a-833d74912d96","frontmatter":{"title":"2015 年终总结","date":"2016 March-23"},"html":"<p>我知道今天是 16 年的 3 月下旬，但是如果按照农历来算的话现在做去年的年终总结也不是很过分吧...不过也真是因为自己很忙很忙，或者是说自己觉得自己很忙很忙才会这个样子。不过 15 年发生了很多很多事情，去过很多很多地方，希望把这些记下来。</p>\n<p>15 年的这个时候我在做什么呢？哦，我应该是在实验室里打酱油然后在等台湾通行证的结果了。再往前呢？在小妮妮没有去台湾之前我们在学校里过着好开心的生活，还记得年前去滑雪，我刚刚踩上滑雪板风一吹就倒了。整个过程自己只有一次成功的从山坡上滑下来但偏偏这一次被摄像头记了下来。晚上回来还去吃了一顿烧烤大餐满足的不得了，可是小妮妮居然都忘记了。</p>\n<p>后来小妮妮去了台湾，我分别在三月底和答辩后的六月中去了两次台湾。还记得第一次刚刚到桃园机场见到小妮妮的样子，那时候下着点小雨，空气潮湿闷热但是十分干净没有一丝泥泞。排队等机场大巴的时候工作人员给我的行李箱上贴上了国光字样的行李验证码。（现在想想，从北京出发去台北的那一天正是我飞来飞去的一年的起点，我大黄色亮晶晶的行李箱从那天开始渐渐贴上了各种乱七八糟的条形码。）第一次去台湾去了两个地方，台北和垦丁，先到台北以台大为中心在周边瞎逛，感觉台湾的吃的又好吃又便宜，台大的园子也不比北大差，椰林大道显得很是气派。感觉在这里交流几个月也真是令人羡慕。去垦丁恰好赶在了垦丁的春浪之前，所以人还不多，民宿的价格也还比较便宜，不过就是交通不太方便，先坐高铁到了左营然后租车开了一两个小时才来到垦丁。在垦丁住的地方穿过一条马路就是海边，当天晚上跑去海边走了一下没什么感觉就回来了。但第二天早晨爬起来拉开窗帘的时候就惊呆了。那是一个大晴天，基本无风，太阳把海面照的湛蓝湛蓝的，在别的地方没有见过这样的海面哎！然后只有两个人的卡丁车跑道也真是奢侈，如果还能再去垦丁一定要再跑上几把。</p>\n<p><img src=\"/img/in-post/2015-review/sea.jpg\" alt=\"垦丁\"></p>\n<p>第二次去台湾相对于第一次安排的更周密一些，我们去了北投泡温泉，去了澎湖骑机车看落日钓小管，去了台中蓬甲夜市又回到台北吃吃吃。澎湖的一大特色就是没有人，在只有两个人的公路上任意驰骋在大陆真是不敢想。然后最后去的山水沙滩真的是美到爆，后悔没有住在海边了。最后我们还没有直接回北京而是跑去厦门玩了两天。相比台湾干净的海水，厦门的海实在是没什么可看的，但是相比台湾没有滋味的海鲜，厦门的爆炒花蛤真是好吃爆了，我们甚至留下了和两盘花蛤的合影。</p>\n<p><img src=\"/img/in-post/2015-review/penghu.jpg\" alt=\"澎湖\"></p>\n<p>然后我就毕业了，终于毕业了。毕业搬家的时候那叫一个匆忙，我好像是突然就把东西打包好送去了邮局。我只记得当时老季过来帮我把一堆东西搬到了他那里，第二天就去了杭州，匆匆到记不清当时宿舍里还有几个人。在杭州闲了没多久就回家继续闲着，但是闲了没几天就又回到北京准备入职工作了。刚到北京那几天特别艰难，由于我马上去印度培训，没有租房子，自己在同学宿舍的地板上借住了一宿又自己跑去公司附近的宾馆住了两天，那两天我拉着行李箱跑来跑去真是怀念有宿舍的日子。可没想到在之后的大半年里都一直保持这种状态...</p>\n<p>8月10号我入职 tw，14号就和几个新入职的同事一起去了印度参加 twu 的培训。为期 5 周的培训课程相当的密集，也相当的辛苦。9月下旬回到北京暂住公司公寓直到10月底开始了小巨人的培训。在成都为期三周的培训让 twu 显得那么的苍白无力。一周 80 个小时的开发时间完全碾压以前任意时段的工作强度。这里培训也把我带入了一个全新的软件设计领域。从此我更注重时间管理，任务拆分，模型设计和单据追朔，DDD的书籍至今也不离手，反复的阅读希望可以有更深入的理解。</p>\n<p><img src=\"/img/in-post/2015-review/chengdu.jpg\" alt=\"小巨人培训\"></p>\n<p>工作之后只在北京待过一个月，其他的时间都在出差。从北京到成都，从成都到武汉，从武汉到西安从西安到深圳，从深圳去北京再从北京回到西安。相对来说西安是待的时间最长的地方。每天大部分时间都在写程序，看书，有点闷，但是希望可以闷出成绩，做出好的东西。</p>\n<p><img src=\"/img/in-post/2015-review/flight.jpg\" alt=\"航线\"></p>\n<p>流水账就说道这里吧。</p>\n<p>15年8月份之前我依然主力做有关数据方面的东西，参见了天池的大数据竞赛，其中的资金流入流出比赛做的还可以。深深感慨到现在的这样的数据平台才是推动生产力发展的关键：以前大家辛辛苦苦优化的结果通过高计算能力的集群轻松的突破了，超大规模的 GBDT 这样基本不可能的事情成为了可能。再看单机上 xgboost 这样的工具也让我可以在任何特征都筛选的时候做到非常高的分值。benchmark 相对于从前真是高出了不少。个人认为数据和机器智能的发展可以在很短的时间内达到一个不错的程度，自己在最近也尽量抽空做点点比赛，但是感觉这样的游击战并不能真正的提升自己这方面的能力，还是需要在接下来的一年更系统的去学习相关的知识。</p>\n<p>8月份入职之后似乎进入了一个和数据不沾边的领域。之前想的非常清楚了，之所以来 tw 是因为对自己的系统设计能力不满意。我自己觉得不论是做什么样子的具体的软件和系统，前期的设计和架构能力都是必要的能力。另一方面，生产力是最有说服力的东西，如果我可以把软件做的比比人快很多但是又有很好的设计和架构以支持未来的自由扩展，那具体到做什么样子的东西来说都会游刃有余。半年过去了，我觉得来到这里是非常值得的，在软件设计方面相比从前真的是有了一个不小的提升。一直希望自己可以具备快速的构建一个项目的能力，从设计到编码，从前端到后端都可以用最快的速度完成。现在感觉自己离具备这个能力又进了一步。不过一切都才刚刚开始。也希望自己在今年开始做一些更靠谱的项目。</p>\n<p>上班之后也开始更强烈的感受到了生活的压力，上学的时候吃住的花销不大加上自己的实习和 freelancer 的项目还能有个不错的收入，上班之后发现吃住的花销也还真是惊人，最近开始注意记账追朔自己的花销，在财务上开始培养一些好习惯，真正的效果上还是要靠坚持才行。</p>\n<p>和小妮妮这一年真是聚少离多，四处奔波的日子也是挺让人烦的。小妮妮毕业之前还可以随我一起去各个城市玩玩，自一月份以后就没有这样子的机会了。希望今年可以好好想想，想想以后的规划安排，改变现在的局面。</p>\n<p>最后，博客不能停，多多总结，免得自己忘记了。</p>","fields":{"slug_without_date":"/2015-annual-review"}},{"id":"ffabc1e9-1274-5d03-a782-ddb533711d19","frontmatter":{"title":"CIKM query detection","date":"2014 August-13"},"html":"<p>自上次做了阿里的比赛之后似乎有点不过瘾，趁巧发现群里在宣传百度与 cikm 合作的这个比赛，于是\n又来打酱油。之前的比赛搞的有点混乱，这次想把思路捋顺清楚。就用这个新的 blog把一些关键的东西\n记下来吧。</p>\n<h2 id=\"Task\" style=\"position:relative;\">Task<a href=\"#Task\" aria-label=\"Task permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>首先说一下大体的比赛任务：对给出的搜索词(query)做分类。百度对一些搜索词做了人工标注，然后给\n出了这些数据在 session 中的查询以及点击的页面标题。然后要对另一批标记为 TEST 的数据做标注。\n而在 session 中出现的并没有标记的 query 被标记为 UNKNONW。</p>\n<h2 id=\"Baselines\" style=\"position:relative;\">Baselines<a href=\"#Baselines\" aria-label=\"Baselines permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"naive-baseline-1\" style=\"position:relative;\">naive baseline 1<a href=\"#naive-baseline-1\" aria-label=\"naive baseline 1 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>大体思路是首先处理已经有标记的数据，取标记数据的 query, title 的前 N 个字符然后标记这个\nprefix 的标签为当前的 label。如果出现了同一个 prefix 有多个标签的情况，就把这个 prefix\n的标签设置成有最多标记次数的标签。</p>\n<p>然后读取 test 数据，同样取 test query 的前 N 个字符字符，然后在之前的 query-label 对中查看这个 prefix 是否存在，如果\n存在就设置 prefix 为 label，否则就设置成 OTHER。</p>\n<p>这个 baseline 可以得到大概 34% 的结果。</p>\n<h3 id=\"naive-baseline-2\" style=\"position:relative;\">naive baseline 2<a href=\"#naive-baseline-2\" aria-label=\"naive baseline 2 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>如果说上面的那个似乎有点低了，那么这个我刚刚想到的 baseline 就靠谱多了。</p>\n<p>仔细观察数据会发现这样子的 session:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">CLASS=TEST\t0417191 0750813 0396059\t-\nCLASS=LOTTERY\t0417191 0750813 0396059 0040630 0030792 0079323 0387331\t-\nCLASS=LOTTERY\t0417191 0750813 0396059 0040630 0030792 0079323 0387331\t0557667 0208773 0631387 0949083 0040630 0030792 0750813 0396059 0490159 0293898 0514247 0754212 0208773 0631387 0949083 0040630 0030792 0750813 0396059 0297573 0040630 0030792 0750813 0396059 0293898 0998010 0359806 0040630 0030792 0580929\nCLASS=LOTTERY\t0417191 0750813 0396059 0040630 0030792 0079323 0387331\t0557667 0208773 0631387 0949083 0040630 0030792 0750813 0396059 0490159 0293898 0514247 0754212 0208773 0631387 0949083 0040630 0030792 0750813 0396059 0297573 0040630 0030792 0750813 0396059 0293898 0998010 0359806 0040630 0030792 0580929\nCLASS=LOTTERY\t0417191 0750813 0396059 0040630 0030792 0079323 0387331\t0949083 0750813 0396059 0040630 0030792 0079323 0387331 1116997 0040630 0030792 0079323 0387331 0750813 0396059 0729226 1081042 0754212 0631387 0976685 0694263\nCLASS=LOTTERY\t0417191 0750813 0396059 0040630 0030792 0079323 0387331\t0949083 0750813 0396059 0438139 0396059 1081042 0729226 0784491 0208773 0631387 0949083 0750813 0396059 0438139 0396059 1081042 0729226 0846596 0750813 0396059 1081042 0729226 0846596 0438139 0396059 1081042 0729226 0297573 0781505 0878719</code></pre></div>\n<p>标记为 TEST 的与有标记的数据出现在了同一个 session 之中，然后我觉得在同一个 session 中的 query 的动机应该是极其类似的。\n那么我就做一个非常粗略的判定：同一个 session 中的 label 应该是一样的。那么，我们就可以把既有 TEST 标签又有标定的数据的 session 中的 query 全部设置为这个已标定的标签。然后我发现在 session 中出现 label 的情况还是挺多的，经过以上规则的标定，我可以找出 21000+ 个这样的 test query 的标签，\n然后把剩下的 query 标记为出现最多的 VIDEO。这样的线上提交结果达到了 67%。</p>\n<hr>\n<p>以上是一些比较基本的提交，为的是大概了解数据的情况以及提交数据的样子。后面就是一些模型的尝试了。</p>\n<h2 id=\"Ngram\" style=\"position:relative;\">Ngram<a href=\"#Ngram\" aria-label=\"Ngram permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>做文本的分类，肯定会想到用 bag of word 抽取特征，然后用一些模型去做分类了。我一开始也是这个思路，迅速的用 sklearn 的 TfidfVectorizer 对标记了的 query + title 做了 BOW 然后用 NaiveBayes 去预测结果。\n用一元文法、二元文法、三元文法做了尝试之后发现三元的效果比较好，就用三元的提交了一个结果，线上的结果是 80% 了呢，感觉还算靠谱。然后又尝试了 LogisticRegression 以及 LinearSVC 的模型，结果也有所提升。</p>\n<p>然后...似乎就不知道要做什么了...跑去群里和别人讨论了一下，发现如果仅仅使用 query 而不用 title 的数据反而会有所提升。于是我也用了这个方法，最后达到目前的最高分 84.61% ...</p>\n<h2 id=\"Word\" style=\"position:relative;\">Word<a href=\"#Word\" aria-label=\"Word permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>目前的数据是加了密的，每个 string 对应一个中文的汉字或者是一个英文的词，那么前面的 Ngram 还是比较粗糙的，看了之前百度的比赛，获胜选手都是要首先做分词来着。\n虽然这里加了密，但是依然可以尝试一些无词典的分词方式进行分词的。我这里参见了 matrix67 的一篇旧文，首先从目前的数据生成出一个词典来，然后再用 mmseg 做分词。\n我本来以为这是一个很不错的主意，但是在实现的过程过程中发现这个生成词典的计算量非常的大...程序中有一部分是计算一个词的子词构成这个词的概率，内存和 cpu\n都有点吃不消，在尝试计算前三千万数据失败之后我只好使用了计算前一千万数据的结果做为词典。然后把分词之后的 bag of word 与之前的 3ngram bow 组合计算了一个新的 svm\n的模型，结果...结果降了 T_T。这尼玛是为什么。难道分词太差劲了么？而且，事实上，我自己本地测试的数据是提升了几个百分点的，虽然提升的不多，但是总不至于降低吧...\n我甚至有点怀疑，目前的线上测试集因为是全体测试数据的一个子集，所以还是不能太信它的，过拟合了的话就没有意义了。</p>\n<p>不过真的是郁闷了...</p>\n<p>然后就开始考虑各种情况了，比如那么多的 UNKNOWN 数据都没有使用啊，要怎么使用才对吧？但是要怎么使用呢，因为同一个 session 下的数据标定为同一个 label 的结果只有 67% 啊，\n也就是说我不能随便判断这个 UNKNOWN 真实的标签是什么才对呢...所以说，可以考虑 <strong>如何对 test 与 labeled 在同一个 session 的情况下做标定</strong> 着手，为对 UNKNOWN 数据的标定提供参考。</p>\n<p>然后就是 title 的数据如何利用？看起来 title 会引入很多的噪声，那么 title 数据可不可以做一些额外的处理来降噪后加以利用呢?</p>\n<h2 id=\"Add-title-and-query-together\" style=\"position:relative;\">Add title and query together<a href=\"#Add-title-and-query-together\" aria-label=\"Add title and query together permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>之前就考虑过说把 title 考虑进去，却导致了结果的下降，这次在考虑 word 的同时，把 title 添加了进去。而且，取得是 title 的前 N 个字符，这样就可以过滤掉后面那些噪音了。\n当然，在生成测试集的标签的时候同样是把 test data 的 title 考虑在内去处理。然后目前的得分是 <code class=\"language-text\">87.39%</code>。</p>\n<hr>\n<h2 id=\"2014-10-01-结束后的总结\" style=\"position:relative;\">2014-10-01 结束后的总结<a href=\"#2014-10-01-%E7%BB%93%E6%9D%9F%E5%90%8E%E7%9A%84%E6%80%BB%E7%BB%93\" aria-label=\"2014 10 01 结束后的总结 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>这...都说懒是没得救的，我差不多了。这 blog 上次写还是 8 月份。</p>\n<p>今天按理说是比赛结束了吧？可是我发现怎么还有人在提交到 leaderboard 呢...百度的同学们放假了是吧？既然知道要放假你们为毛要把结束时间设置到 10 月 1 号呢。</p>\n<p>好了，不废话了。说一说我自己的最好成绩是怎么做的吧...其实我也是小白，半路出家，找个类库瞎试，有什么不对的地方请指出。</p>\n<p>我这个比赛主要就是在使用 <code class=\"language-text\">scikit-learn</code> 做训练的基础库。抽特征，训模型都是靠的它。后面说到的一些内容我尽量不涉及具体的库，不过还是要宣传一下，我感觉它还是很不错的呢。</p>\n<h3 id=\"数据预处理\" style=\"position:relative;\">数据预处理<a href=\"#%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86\" aria-label=\"数据预处理 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>原始数据是按照 session 组织的，既然我们要做的是 query detection，我首先是把相同 query 的数据集合在一起。大概的形式如下</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">label   query   text\n1       121     121 123 124 ...</code></pre></div>\n<p>其中 text 也要包含 query 的内容，然后 text 中没有重复的 query 以及 title。并且剔除了 CLASS=UNKNOWN 的数据。</p>\n<p>按照这样处理后，训练数据就只有 79M 了。</p>\n<h3 id=\"特征\" style=\"position:relative;\">特征<a href=\"#%E7%89%B9%E5%BE%81\" aria-label=\"特征 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ol>\n<li>3gram</li>\n<li>做了分词之后的 2gram 分词见上文</li>\n<li>prefix 比如 text 为 \"1 2 3 4 5\" 那么，生成的 prefix 就是 \"1\", \"1 2\", \"1 2 3\"...</li>\n<li>postfix 比如 text 为 \"1 2 3 4 5\" 那么，生成的 postfix 就是 \"5\", \"4 5\", \"3 4 5\"...</li>\n</ol>\n<h3 id=\"模型\" style=\"position:relative;\">模型<a href=\"#%E6%A8%A1%E5%9E%8B\" aria-label=\"模型 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>LinearSVC 或者说是 liblinear</p>\n<p>然后，没了...就是这样，LinearSVC 没怎么调参，随便改个参数都没有默认的好...最后 leaderboard 上 89.91</p>\n<h2 id=\"总结\" style=\"position:relative;\">总结<a href=\"#%E6%80%BB%E7%BB%93\" aria-label=\"总结 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ol>\n<li>sklearn 是个好东西，里面的 model 算是挺全的，然后 gridsearch 做调参很爽</li>\n<li>我没有用其他的工具，这个其实并不好，yr_SYSU 推荐了 vowpal wabbit 以后有机会去试试</li>\n<li>unknown 根本没有使用，本来我是有尝试的，比如对有 label 的临近的 unknown 标定为相同的 label 但是这样反而导致结果的下降</li>\n<li>尝试了词向量，也是下降了，悲剧的</li>\n<li>分词其实提升也很有限...就一点点，看群里说分词是必须的，可我其实觉得这加过密的数据做分词都不知道效果，有的时候加了都不如不加吧</li>\n<li>没做模型融合</li>\n</ol>","fields":{"slug_without_date":"/cikm-query-detection"}}],"pageInfo":{"hasPreviousPage":true,"currentPage":13,"pageCount":22}}},"pageContext":{"limit":5,"skip":60}},"staticQueryHashes":[]}