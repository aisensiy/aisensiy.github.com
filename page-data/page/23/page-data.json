{"componentChunkName":"component---src-templates-blogs-js","path":"/page/23","result":{"data":{"site":{"siteMetadata":{"title":"eisen-s-blog"}},"blogs":{"nodes":[{"id":"e2cb0ff6-8341-50d0-aee1-2ad7ac7bee1b","frontmatter":{"title":"Webpack Scss Loader","date":"2016 May-09"},"html":"<h2 id=\"add-css-in-webpack\" style=\"position:relative;\">Add css in webpack<a href=\"#add-css-in-webpack\" aria-label=\"add css in webpack permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>前面介绍了 <code>webpack</code> 的 <code>loader</code> 也提及了它是用来将各种语言转换成 js 的翻译器。但是有一个特殊的情况，就是有一个 <code>style-loader</code> 和 <code>css-loader</code>，他们并不是 <code>js</code> 但是最终可以以 <code>text</code> 的形式放到我们打包的那个文件 <code>bundle.js</code> 中去，并且这里是将两个 <code>loader</code> 一起使用，有点像是 <code>filter &#x26; pipeline</code> 的模式。虽然这里的 <code>style-loader</code> 并不知道为什么要单独分出来，听起来好像是 <code>html</code> 的 style 还可以有除了 <code>css</code> 之外的东西，不明觉厉。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">css file  | css-loader | style-loader > bundle.js</code></pre></div>\n<p>当然，我们现在都不怎么写纯粹的 <code>css</code> 了，都是采用 <code>less</code> 或者是 <code>sass</code> 写了之后再翻译成 <code>css</code>，<code>webpack</code> 也支持 <code>sass-loader</code> 这样的东西，最终的流程是这样子的：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">sass file | sass-loader | css-loader | style-loader > bundle.js</code></pre></div>\n<h2 id=\"一个例子\" style=\"position:relative;\">一个例子<a href=\"#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90\" aria-label=\"一个例子 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>首先安装 <code>sass-loader</code> 以及其所依赖的 <code>sass</code> to <code>css</code> 的翻译器 <code>node-sass</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ npm install --save-dev sass-loader node-sass</code></pre></div>\n<p>然后安装 <code>style-loader</code> 以及 <code>css-loader</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">$ npm install --save-dev style-loader css-loader</code></pre></div>\n<p>和配置 <code>es2015</code> 类似，在 <code>webpack.config.js</code> 中添加 <code>loader</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var path = require(\"path\");\n\nmodule.exports = {\n  entry: [\n    './entry'\n  ],\n  output: {\n    path: path.join(__dirname, \"dist\"),\n    filename: \"bundle.js\"\n  },\n  module: {\n    loaders: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: \"babel-loader\",\n        query: {\n          presets: ['es2015']\n        }\n      },\n      {\n        test: /\\.scss$/,\n        exclude: /node_modules/,\n        loader: \"style!css!sass\"\n      }\n    ]\n  }\n};</code></pre></div>\n<p>这里的 <code>loader</code> 是一个 <code>pipeline</code> 的感觉，和 <code>es2015</code> 的有些不一样。多个 <code>loader</code> 以 <code>!</code> 分隔，并且顺序是倒序的。</p>\n<p>然后我们添加一个 <code>styles</code> 的目录，并且添加两个 <code>scss</code> 文件</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">.\n├── dist\n│   ├── bundle.js\n│   └── index.html\n├── entry.js\n├── module1.js\n├── module2.js\n├── package.json\n├── styles\n│   ├── index.scss\n│   └── theme.scss\n└── webpack.config.js</code></pre></div>\n<p><code>index.scss</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">@import './theme.scss';</code></pre></div>\n<p><code>theme.scss</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">body {\n  background-color: yellow;\n}</code></pre></div>\n<p>这里只用了一个 <code>@import</code> 的 <code>scss</code> 语法，不过这样也应该足够验证 <code>scss</code> 了。</p>\n<p>最后，在 <code>entry.js</code> 中添加对 <code>index.scss</code> 的引用。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import m1 from './module1'\nimport m2 from './module2'\n\nrequire('./styles/index.scss')\n\nm1();\nm2();</code></pre></div>\n<p>对的，不要怀疑，就是在 <code>js</code> 里面引入了 <code>scss</code>，<code>npm start</code> 一下，看看是不是 <code>body</code> 的背景色变了。</p>\n<h2 id=\"拆分-css-和-js\" style=\"position:relative;\">拆分 css 和 js<a href=\"#%E6%8B%86%E5%88%86-css-%E5%92%8C-js\" aria-label=\"拆分 css 和 js permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>不过 <code>css</code> 和 <code>js</code> 放在一起总觉得怪怪的，可不可以拆分出来？当然可以了，这里需要一个额外的 <code>webpack</code> 插件。<code>plugin</code> 有点像是 <code>webpack</code> 的 <code>postprocessor</code> 是在 <code>webpack</code> 打包之后进行进一步处理的工具。这里我们用到了 <a href=\"https://github.com/webpack/extract-text-webpack-plugin\">extract-text-webpack-plugin</a> 把 <code>css</code> 拆分出来放到一个单独的文件中。</p>\n<p>首先安装</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">npm install --save-dev extract-text-webpack-plugin</code></pre></div>\n<p>然后修改 <code>webpack.config.js</code> 注册这个插件</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var path = require(\"path\");\nvar ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\n\nmodule.exports = {\n  entry: [\n    './entry'\n  ],\n  output: {\n    path: path.join(__dirname, \"dist\"),\n    filename: \"bundle.js\"\n  },\n  module: {\n    loaders: [\n      {\n        test: /\\.js$/,\n        exclude: /node_modules/,\n        loader: \"babel-loader\",\n        query: {\n          presets: ['es2015']\n        }\n      },\n      {\n        test: /\\.scss$/,\n        exclude: /node_modules/,\n        loader: ExtractTextPlugin.extract(\"style-loader\", \"css-loader\", \"sass-loader\")\n      }\n    ]\n  },\n  plugins: [\n    new ExtractTextPlugin(\"styles.css\")\n  ]\n};</code></pre></div>\n<p>注意，我们的 <code>loader</code> 这部分也会采用 <code>ExtractTextPlugin</code> 进行重写</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">loader: ExtractTextPlugin.extract(\"style-loader\", \"css-loader\", \"sass-loader\")</code></pre></div>\n<p>然后 <code>plugin</code> 这部分说明我们最终要将 <code>css</code> 文件保存为 <code>styles.css</code>，这里要说明的是 <code>styles.css</code> 文件是要遵循 <code>webpack.config.js</code> 文件中的 <code>output</code> 路径的，也就是说它会保存到 <code>dist/styles.css</code>。我们修改一下 <code>index.html</code>，引入这个文件</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;html>\n&lt;head>\n  &lt;meta charset=\"UTF-8\">\n  &lt;title>Document&lt;/title>\n  &lt;link rel=\"stylesheet\" href=\"styles.css\" type=\"text/css\" media=\"screen\" title=\"no title\" charset=\"utf-8\">\n&lt;/head>\n&lt;body>\n  &lt;script type=\"text/javascript\" src=\"bundle.js\">&lt;/script>\n&lt;/body>\n&lt;/html></code></pre></div>\n<p>执行 <code>webpack</code> 看看是不是在 <code>dist</code> 下多了一个 <code>styles.css</code>。</p>\n<h2 id=\"参考\" style=\"position:relative;\">参考<a href=\"#%E5%8F%82%E8%80%83\" aria-label=\"参考 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ol>\n<li><a href=\"https://webpack.github.io/docs/tutorials/getting-started/\">webpack get started</a></li>\n<li><a href=\"https://webpack.github.io/docs/loaders.html#loader-order\">webpack loader order</a></li>\n<li><a href=\"https://github.com/webpack/docs/wiki/list-of-plugins\">webpack plugins</a></li>\n<li><a href=\"https://github.com/webpack/extract-text-webpack-plugin\">extract-text-webpack-plugin</a></li>\n</ol>","fields":{"slug_without_date":"/webpack-scss-loader"}},{"id":"899b6565-2be7-5b8e-a295-1d576ad8729d","frontmatter":{"title":"Webpack Setup","date":"2016 May-05"},"html":"<p>虽然用 <code>webpack</code> 有一阵子了，但是上次构建整个体系的时候手忙脚乱的，仅仅是找了乱七八糟的东西堆叠起来，中间的过程忘的一干二净今天去 review 自己以前写的代码完全不知道自己是怎么搞定的。这次写一个小系列把如何构建 <code>webpack</code> + <code>redux</code> + <code>react</code> 的体系记下来，今天是第一部分，<code>webpack</code> 的准备工作。</p>\n<p><code>webpack</code> 可以认为就是一个 <code>node</code> 版本的 <code>make</code> 吧，不过自然是有 <code>js</code> 特色的 <code>make</code> 了，类似的东西有很多，比如 <code>browserify</code> 以及 <code>gulp</code> 等。<code>webpack</code> 最终的目的就是将我们一个有众多文件的 <code>js</code> 的 project 变成只有一个或者多个文件的 <code>bundles</code>，我在后面会结合例子做展示。并且<code>webpack</code> 可以支持 <code>loader</code> 将各种诡异的 <code>js</code> 方言转换成 <code>js</code> 比如当下比较流行的额 <code>babel</code> <code>jsx</code> 等，所以 <code>webpack</code> 配合 <code>es2015</code> 以及 <code>react</code> 一起使用非常的方便。不过要说明的是对这些方言的支持是 <code>loader</code> 的事情，<code>webpack</code> 本身是只能处理原生态的 <code>js</code> 的。</p>\n<h2 id=\"basic\" style=\"position:relative;\">basic<a href=\"#basic\" aria-label=\"basic permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>首先自然是安装 <code>webpack</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">npm install -g webpack\nnpm install -S webpack</code></pre></div>\n<p>然后我展示一个 <code>webpack</code> 的基本用法。首先看一下我们的目录结构：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">├── index.html\n├── index.js\n├── module1.js\n├── module2.js\n└── package.json</code></pre></div>\n<p>其中 <code>index.html</code> 基本就是一个空文件</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;html>\n  &lt;head>\n    &lt;meta charset=\"utf-8\">\n    &lt;title>index&lt;/title>\n  &lt;/head>\n  &lt;body>\n    &lt;script src=\"bundle.js\">&lt;/script>\n  &lt;/body>\n&lt;/html></code></pre></div>\n<p><code>module1.js</code> <code>module2.js</code> 展示如下</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log('module 1');</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log(\"module 2\");</code></pre></div>\n<p><code>index.js</code> 通过 <code>require</code> 的方式引用两个模块</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">require(\"./module1\");\nrequire(\"./module2\");</code></pre></div>\n<p>然后通过命令 <code>webpack ./index.js bundle.js</code> 可以将 <code>index.js</code> 以及其所依赖的模块打包生成一个文件 <code>bundle.js</code> 这样在浏览器打开 <code>index.html</code> 就可以看到 <code>console</code> 中的命令了。</p>\n<h2 id=\"use-webpackconfigjs\" style=\"position:relative;\">use webpack.config.js<a href=\"#use-webpackconfigjs\" aria-label=\"use webpackconfigjs permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>在上述这么简单的情况下我们就仅仅用 <code>webpack</code> 的命令就可以了。不过在处理更复杂的事情的时候需要 <code>webpack.config.js</code> 来帮忙。这里我给出一个最小化的 <code>webpack.config.js</code> 的实例来替代刚才的命令。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var path = require(\"path\");\n\nmodule.exports = {\n  entry: [\n    './index'\n  ],\n  output: {\n    path: path.join(__dirname, \"dist\"),\n    filename: \"bundle.js\"\n  }\n};</code></pre></div>\n<p>其中，<code>entry</code> 就是我们整个 <code>project</code> 的 <code>main</code>。就如在前文中 <code>webpack ./index.js bundle.js</code> 的 <code>./index.js</code> 的角色。<code>output</code> 则表示我们要将生成的 <code>js</code> 放在哪里。这里我提供了一个不同的 <code>path</code>: <code>dist</code>，然后依然采用 <code>bundle.js</code> 的名字。这样我们执行 <code>webpack</code> 就可以看到 <code>dist</code> 下出现了 <code>bundle.js</code> 这个文件。</p>\n<h2 id=\"use-webpack-dev-server\" style=\"position:relative;\">use webpack dev server<a href=\"#use-webpack-dev-server\" aria-label=\"use webpack dev server permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>那么每次改了文件之后都 <code>webpack</code> 是不是很麻烦，应该是有 <code>watch</code> 的办法吧。对的，这就是 <code>webpack-dev-server</code> 了。首先安装它。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">npm install -g webpack-dev-server\nnpm install -S webpack-dev-server</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">执行 `webpack-dev-server --inline --hot --content-base dist/`，每次修改代码就可以自动 build 了。</code></pre></div>\n<p>既然这里我们把 <code>content-base</code> 设定为了 <code>dist</code> 那么需要把 <code>index.html</code> 放进去啦。最后的目录结构是这样子的：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">├── dist\n│   ├── bundle.js\n│   └── index.html\n├── index.js\n├── module1.js\n├── module2.js\n├── package.json\n└── webpack.config.js</code></pre></div>\n<p>值得一提是在 <code>package.json</code> 里有一个专门放置这种启动 server 的地方，就是在 <code>scripts</code> 下:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">{\n  \"name\": \"webpack-setup\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"webpack\": \"^1.13.0\"\n  }\n}</code></pre></div>\n<p>然后下次执行 <code>npm start</code> 就可以启动这个 dev server 啦。</p>\n<h2 id=\"一些参考\" style=\"position:relative;\">一些参考<a href=\"#%E4%B8%80%E4%BA%9B%E5%8F%82%E8%80%83\" aria-label=\"一些参考 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ol>\n<li>webpack.config.js <a href=\"http://webpack.github.io/docs/configuration.html\">https:://webpack.github.io/docs/configuration.html</a></li>\n<li>webpack dev server <a href=\"http://webpack.github.io/docs/webpack-dev-server.html\">https:://webpack.github.io/docs/webpack-dev-server.html</a></li>\n</ol>","fields":{"slug_without_date":"/webpack-setup"}},{"id":"9ae10e2a-5c45-5b23-9ab6-815122790251","frontmatter":{"title":"Some tips about DDD","date":"2016 April-20"},"html":"<p>DDD 即 Domain Driven Design, 领域驱动设计，似乎是一个比较老的东西了，2003 年这本书就出版了。不过这么多年来我是从来都没有知晓过，直到参加了小巨人的培训。在培训的过程中，我自己尝试自己对某个领域进行建模并且以 REST API 的形式实现自己的设计，而整个过程中都要尽量的遵循 DDD 的一些设计原则，可惜培训时间太短了，我需要更多的时间去消化。半年多来我一直都在琢磨这个主题，即使工作任务很重的时候我依然在尝试把以前自己认为不遵循 DDD 设计的一些项目按照我理解的 DDD （对，我理解的，不代表是对的）进行了重写，这虽然花了不少的时间但我认为这是值得的。其中经常出现的几个名词 <code>aggregate</code> <code>value object</code> <code>entity</code> <code>bounded context</code> <code>domain model</code> <code>repository</code> <code>factory</code> 一直以来我总觉得自己没有把它们彻底的搞明白。整个体系对我来说依然没有在我的脑海中建立起来。直到最近，在认认真真的看完了几本 DDD 主题的书籍以及众多有关这个主题的文章和演讲之后，我才觉得我对这方面的理解有了起色，我逐渐的弄明白了 DDD 的真正意图，清楚了 REST 和 DDD 的关系，我才敢写下这篇文章。</p>\n<p>培训中 REST 和 DDD 的主题是被放在一起讲解的，REST 按照 DDD 中 <code>aggregate</code> 的形式被组织在一起。看下面这样一组 REST API:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/users\n/users/:user-id\n/users/:user-id/orders\n/users/:user-id/orders/:order-id</code></pre></div>\n<p><code>user</code> 作为一个 <code>aggregate</code> 的 <code>root</code>，它包含了其下所有的 <code>order</code>。这样最初看起来没什么不妥，<code>order</code> 是随着 <code>user</code> 出现的，<code>order</code> 的生命周期是受 <code>user</code> 控制的。这就像是 Evans 在第六章节举的那个例子，<code>line item</code> 是 <code>order</code> 的一部分。但是在实现这部分 api 的时候我发现我有一点是难以做到的：<code>order</code> 是不能够随着 <code>user</code> 一起载入到内存的，它不像是 <code>order</code> 与 <code>order line item</code> 那样的关系。user's orders 这个集合是可以不断的扩张的，我甚至不能把一个用户所有的 order 一次性的载入到内存中，我需要分页，我需要根据默写规则对用户的订单进行筛选。此时再仔细想想 DDD 的那个例子，里面涉及了很多的并发冲突，然而当我需要拿到用户以及查询订单的时候会有什么呢？没有，什么冲突都不会发生。逐渐的我才明白其实我一开始就理解错了。事实上，<strong>DDD 关注的是一个写模型</strong>，并发的冲突都是在有写操作的时候才会出现。例子中的创建和修改订单都是写，而我所要考虑的仅仅是读而已，读事实上什么麻烦都不会产生，怎么读都不会产生问题。</p>\n<p>再去看看 Implementing DDD 这本书的例子，<code>application</code> 这个 package 被分成了两部分，一部分是 <code>Query</code> 一部分是 <code>Command</code>，没错就是 CQRS 的思路。一个个 <code>Command</code> 调用了 <code>domain</code> 中的对象和方法，实现了关键的业务。而 <code>Query</code> 的 Data Model 和 Domain Model 有质的区别，Query Service 甚至是直接拼装了 HQL (Hibernate SQL)。它更多的是面向 UI 的：需要展示什么就提供什么。那么这样来看，很多事情就迎刃而解了。</p>\n<p>简单的来讲，aggregate 就是为了解决一个并发的问题。aggregate 就是定义了一个业务场景中最小的锁单元：任何人对一个 aggregate 操作时其他人都不能再对这个单元进行操作了。而整个业务中数据的一致性也是由这样的方式得到了保证。那么回到上面的例子，<code>user</code> 下的 <code>order</code> 是没有道理和 <code>user</code> 建立为一个 <code>aggregate</code> 的。<code>user</code> 和 <code>order</code> 分别是一个单 <code>entity</code> 的 <code>aggregte</code>。</p>\n<p>DDD 仅仅是一个写模型。在通过 REST API 暴露一个 Domain 的接口的时候要明确每一个方法分别对应了相应资源下的什么操作。虽然很多的数据和演讲中强调 REST 和 DDD 没关系，并且 Rest 的 Resource 也和 DDD 中的 Entity 没有映射关系，但是我个人觉得从 UL 的角度来说，外部所看到的东西和 Domain 所提及的东西应当一致，只是 REST 会隐藏很多细节罢了。当然，这里所谓的隐藏细节也可能隐藏的多到内外的概念是不一致的。其中 <code>GET</code> 和其他操作相比有着质的区别，它可能采用了纯粹的 DTO 而不涉及任何的 Domain，这样在实现模型的时候我们就不必小心翼翼的去让 Domain Model 尽量的和 Rest 所需要获取的数据保持一致了。这也是我自己在整个过程中最困惑的地方了。</p>\n<p>到这里，按照 DDD 设计的思路就清楚多了，我不再担心如何让 GET 方法从 Domain 中拿到它想要的东西了。我可以在设计的时候首先关注更重要的业务流程，然后在需要的时候用最简单的方式提供相应的 Query Service 即可。</p>","fields":{"slug_without_date":"/some-tips-for-ddd"}}],"pageInfo":{"hasPreviousPage":true,"currentPage":23,"pageCount":39}}},"pageContext":{"limit":3,"skip":66}},"staticQueryHashes":[]}