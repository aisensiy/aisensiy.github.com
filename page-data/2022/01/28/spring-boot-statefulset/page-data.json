{
    "componentChunkName": "component---src-templates-blog-js",
    "path": "/2022/01/28/spring-boot-statefulset/",
    "result": {"data":{"blog":{"id":"fd5a53ec-c639-5fcc-b74c-708829d02df4","html":"<p>最近在做几个小服务的重构，希望把拆出来的小服务放回主服务里面，有这么几个方面的考虑：</p>\n<ol>\n<li>小服务本身和主服务是从属关系，完全服务于主服务，合并回去完全没有什么业务上的障碍</li>\n<li>合并之后感觉业务的内聚性更好了，可以减少一些外部接口，改为模块间直接调用，获取更好的性能</li>\n<li>当然从部署上，部署一个东西总是比部署两个东西要好一些，而且这种小服务真的很小，没有为原来的系统增加什么负担</li>\n</ol>\n<p>不过既然想到合并，那么就是回顾下当初为什么拆分成两个：</p>\n<ol>\n<li>感觉有点过度工程化思维了，本来以为这个功能会变得越来越复杂，但事实并没有</li>\n<li>技术上有点点小困难，因为这个小服务不能像主服务那样自由的创建多个副本，原则上一套服务应该只有一个运行，合并到一起似乎做不到，就干脆拿出来了，那合并回来就需要解决这个问题</li>\n</ol>\n<p>这里记录的内容基本都是针对上面的多副本处理的，即如何让 spring boot 的项目在可以多副本的情况下只让其中一个副本运行额外的内容。</p>\n<h2 id=\"区分主--从服务\" style=\"position:relative;\">区分主 / 从服务<a href=\"#%E5%8C%BA%E5%88%86%E4%B8%BB--%E4%BB%8E%E6%9C%8D%E5%8A%A1\" aria-label=\"区分主  从服务 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>所有的服务都是部署在 k8s 里的，之前主服务是一个 <code>Deployment</code> 每个副本没有任何区别，既然考虑到有主从概念，那第一个想到的就是切换为 <code>Statefulset</code>。它每一个副本是的名字是固定的，比如服务叫 <code>main-server</code> 那第一个副本就是 <code>main-server-0</code> 第二个就是 <code>main-server-1</code> 依次类推。每一个副本是固定的，每次做新的部署都会从高序号开始逐个替换。因此，可以把序号 <code>0</code> 的认为是「主服务」，其他就是「从服务」。然后在「主服务」中运行额外的子服务，其他副本则不运行。</p>\n<p><code>Statefulset</code> 的 <code>Pod</code> 启动后其 <code>HOSTNAME</code> 会被修改为其 <code>Pod</code> 的名字，那么对于 <code>main-server-0</code> 在 <code>Pod</code> 里的每个容器里看到的 <code>HOSTNAME</code> 也就是这个名字了。因此 spring boot 就可以通过这个名字最后是不是以 <code>-0</code> 结尾来区分是不是「主服务」进而去做进一步的操作。</p>\n<p>不过直接判断 <code>HOSTNAME</code> 就会让测试环境比较尴尬了，不能说每次修改 <code>HOSTNAME</code> 来实现不同的运行模式吧，因此这里还是在 <code>Statefulset</code> 启动的时候做了个处理去设置另外一个环境变量 <code>SERVER_ROLE</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\"><span class=\"token coord\">---</span>\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n<span class=\"token unchanged\"><span class=\"token prefix unchanged\"> </span> name: main-server\n<span class=\"token prefix unchanged\"> </span> labels:\n<span class=\"token prefix unchanged\"> </span>   app: main-server\n</span>spec:\n<span class=\"token unchanged\"><span class=\"token prefix unchanged\"> </span> serviceName: \"main-server\"\n<span class=\"token prefix unchanged\"> </span> replicas: 1\n<span class=\"token prefix unchanged\"> </span> selector:\n<span class=\"token prefix unchanged\"> </span>   matchLabels:\n<span class=\"token prefix unchanged\"> </span>     app: main-server\n<span class=\"token prefix unchanged\"> </span> template:\n<span class=\"token prefix unchanged\"> </span>   metadata:\n<span class=\"token prefix unchanged\"> </span>     labels:\n<span class=\"token prefix unchanged\"> </span>       app: main-server\n<span class=\"token prefix unchanged\"> </span>   spec:\n<span class=\"token prefix unchanged\"> </span>     topologySpreadConstraints:\n<span class=\"token prefix unchanged\"> </span>       - labelSelector:\n<span class=\"token prefix unchanged\"> </span>           matchLabels:\n<span class=\"token prefix unchanged\"> </span>             app: main-server\n<span class=\"token prefix unchanged\"> </span>         maxSkew: 1\n<span class=\"token prefix unchanged\"> </span>         topologyKey: kubernetes.io/hostname\n<span class=\"token prefix unchanged\"> </span>         whenUnsatisfiable: ScheduleAnyway\n<span class=\"token prefix unchanged\"> </span>     containers:\n<span class=\"token prefix unchanged\"> </span>     - name: main-server\n<span class=\"token prefix unchanged\"> </span>       image: openbayes/main-server\n</span><span class=\"token inserted-sign inserted\"><span class=\"token prefix inserted\">+</span>       command: [\"sh\"]\n<span class=\"token prefix inserted\">+</span>       args: \n<span class=\"token prefix inserted\">+</span>       - \"-c\"\n<span class=\"token prefix inserted\">+</span>       - \"[ ${HOSTNAME##*-} = '0' ] &amp;&amp; export SERVER_ROLE=master; exec web\"\n</span>\n...</code></pre></div>\n<p><code>#{HOSTNAME##*-}</code> 是截取最后一个 <code>-</code> 后面的部分，这个算是 shell 的一个黑魔法吧，相关的内容见 <a href=\"https://tldp.org/LDP/abs/html/string-manipulation.html\">Advanced Bash Scripting Guide</a>。然后如果是 \"0\" 就设置一个环境变量 <code>SERVER_ROLE=master</code>，然后在执行主程序，就是 <code>web</code>。</p>\n<p><code>SERVER_ROLE</code> 也不是随便来的，它对应了 spring boot 项目下 <a href=\"https://github.com/aisensiy/springboot-scheduler-example/blob/master/src/main/resources/application.yml\"><code>application.yml</code></a> 的 <code>server.role</code> 字段。而这部分就为后面动态加载做了准备。</p>\n<p><strong>注意</strong> 从 <code>Deployment</code> 切换到 <code>StatefulSet</code> 后，默认的 <code>Rolling Update</code> 策略会发生变化，如果 <code>replica=1</code> 是无法实现无缝部署的，也就是说 <code>main-server-0</code> 会先关掉然后再启动，所以最好还是让 <code>replica>=2</code>。</p>\n<h2 id=\"动态加载-spring-configuration\" style=\"position:relative;\">动态加载 Spring Configuration<a href=\"#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD-spring-configuration\" aria-label=\"动态加载 spring configuration permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>事实上这部分是 spring boot 的看家本领，它就是通过各种 autoconfiguration 让 spring 的使用变得非常的容易的。这里使用了 <code>@ConditionalOnProperty</code> 注解实现了配置的动态加载。</p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\"><span class=\"token unchanged\"><span class=\"token prefix unchanged\"> </span> @Configuration\n</span><span class=\"token inserted-sign inserted\"><span class=\"token prefix inserted\">+</span> @ConditionalOnProperty(value = \"server.role\", havingValue = \"master\")\n</span><span class=\"token unchanged\"><span class=\"token prefix unchanged\"> </span> @EnableScheduling\n<span class=\"token prefix unchanged\"> </span> public class SchedulerConfig {\n<span class=\"token prefix unchanged\"> </span> \n<span class=\"token prefix unchanged\"> </span>   @Service\n<span class=\"token prefix unchanged\"> </span>   @Slf4j\n<span class=\"token prefix unchanged\"> </span>   public static class Runner {\n<span class=\"token prefix unchanged\"> </span>     @Scheduled(fixedDelay = 5000)\n<span class=\"token prefix unchanged\"> </span>     public void run() {\n<span class=\"token prefix unchanged\"> </span>       log.info(\"Scheduler is running\");\n<span class=\"token prefix unchanged\"> </span>     }\n<span class=\"token prefix unchanged\"> </span>   }\n<span class=\"token prefix unchanged\"> </span> }</span></code></pre></div>\n<p>当 <code>server.role == master</code> 时，该 <code>Configuration</code> 才会生效，并且执行里面的 <code>Runner</code>。效果如下：</p>\n<p>\n\t\t<video\n\t\t\tsrc=/videos/conditionalonproperty.mp4\n\t\t\twidth=\"1200\"\n\t\t\theight=\"auto\"\n\t\t\tpreload=\"auto\"\n\t\t\tmuted=\"false\"\n\t\t\ttitle=\"/videos/conditionalonproperty.mp4\"\n\t\t\t\n\t\t\tplaysinline\n\t\t\tcontrols\n\t\t\t\n\t\t></video>\n\t</p>\n<p>完整的 demo 内容见 <a href=\"https://github.com/aisensiy/springboot-scheduler-example\">springboot-scheduler-example</a>。</p>","tableOfContents":"<ul>\n<li><a href=\"#%E5%8C%BA%E5%88%86%E4%B8%BB--%E4%BB%8E%E6%9C%8D%E5%8A%A1\">区分主 / 从服务</a></li>\n<li><a href=\"#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD-spring-configuration\">动态加载 Spring Configuration</a></li>\n</ul>","frontmatter":{"title":"使用 statefulset 实现 spring boot 项目的主从区分","date":"January 28, 2022","tags":["statefulset","kubernetes","java","springboot"]},"excerpt":"最近在做几个小服务的重构，希望把拆出来的小服务放回主服务里面，有这么几个方面的考虑： 小服务本身和…"}},"pageContext":{"id":"fd5a53ec-c639-5fcc-b74c-708829d02df4"}},
    "staticQueryHashes": ["4202924991"]}