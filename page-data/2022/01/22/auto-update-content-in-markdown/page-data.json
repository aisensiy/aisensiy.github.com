{"componentChunkName":"component---src-templates-blog-js","path":"/2022/01/22/auto-update-content-in-markdown/","result":{"data":{"blog":{"id":"1dd46bc1-353d-5a52-95f6-1572d359a34e","html":"<h2 id=\"问题\" style=\"position:relative;\">问题<a href=\"#%E9%97%AE%E9%A2%98\" aria-label=\"问题 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>写 blog 的时候经常需要做中英文混排，然后这个混排为了美观需要在中和英文之间添加空格。现在形成习惯了，看到别人没有在中英文混排里添加空格都觉得有点难受。不过之前这个格式要求都靠自己敲空格敲出来的，感觉效率有点低下，恰巧发现了 <a href=\"https://github.com/huacnlee/autocorrect\">autocorrect</a> 这个工具，可以实现这个功能，这里尝试把它和我写 blog 用的 neovim 集成下实现自动格式化的功能。</p>\n<h2 id=\"思路\" style=\"position:relative;\">思路<a href=\"#%E6%80%9D%E8%B7%AF\" aria-label=\"思路 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>首先 <code>autocorrect</code> 本身已经是一个二进制文件了，通过如下命令可以实现对文件的处理：</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ autocorrect <span class=\"token parameter variable\">--fix</span> <span class=\"token operator\">&lt;</span>filepath<span class=\"token operator\">></span></code></pre></div>\n<p>因为 vim 有一些插件可以实现在保存的时候对文件进行格式化而 autocorrect 的处理也可以认为是一种格式化因此思路就很一致了。不过相较于很多格式化工具可以以文本内容的方式传递，autocorrect 只能对文件做修改，流程上会稍微有一点区别。这里我列一下集成思路：</p>\n<ol>\n<li>确定内容更新的时机，由于 autocorrect 只能对文件做处理（而不是传递一段文本）因此必须要在文件更新后再次执行该命令对文件做二次刷新，vim 有一个 <code>autocmd</code> 的命令，可以某些重要的事件发生时（或者发生前后）执行一系列命令，这里就需要监听 <code>BufWritePost</code> 即当 Buf 写成功后执行一个命令</li>\n<li>文件被 autocorrect 更新后需要重新读取，否则当前看到的内容就不是已经做过格式化的内容了，vim 中通过命令 edit 可以将文件重新读取，redraw 命令则可刷新视图</li>\n<li>目前只考虑对 markdown 文件做上述处理，需要首先判别文件类别，只有符合的类别才能做上述处理</li>\n</ol>\n<h2 id=\"具体实现方式\" style=\"position:relative;\">具体实现方式<a href=\"#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\" aria-label=\"具体实现方式 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>我使用的是 neovim 这里就按照它的配置结果做了实现，vim 的实现也是类似的，只是具体的目录结构会有略微区别而已。</p>\n<p><a href=\"https://github.com/aisensiy/dotfiles/blob/master/nvim/after/ftplugin/markdown.vim\"><code>.config/nvim/after/ftplugin/markdown.vim</code></a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"vim\"><pre class=\"language-vim\"><code class=\"language-vim\"><span class=\"token keyword\">function</span><span class=\"token operator\">!</span> <span class=\"token function\">MarkdownFormat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">silent</span> <span class=\"token operator\">!</span>autocorrect <span class=\"token operator\">-</span><span class=\"token operator\">-</span><span class=\"token keyword\">fix</span> <span class=\"token string\">'%:p'</span> <span class=\"token comment\">\"3</span>\n  <span class=\"token keyword\">let</span> <span class=\"token keyword\">view</span> <span class=\"token operator\">=</span> <span class=\"token function\">winsaveview</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>        <span class=\"token comment\">\"4 </span>\n  <span class=\"token keyword\">silent</span> <span class=\"token keyword\">edit</span>                     <span class=\"token comment\">\"5</span>\n  <span class=\"token keyword\">call</span> <span class=\"token function\">winrestview</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">view</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">redraw</span><span class=\"token operator\">!</span>                         <span class=\"token comment\">\"6</span>\n<span class=\"token keyword\">endfunction</span>\n\naugroup markdownFormat            <span class=\"token comment\">\"1</span>\n  <span class=\"token builtin\">autocmd</span><span class=\"token operator\">!</span>                        <span class=\"token comment\">\"2</span>\n  <span class=\"token builtin\">autocmd</span> BufWritePost <span class=\"token operator\">*</span> <span class=\"token keyword\">if</span> &amp;<span class=\"token keyword\">filetype</span> <span class=\"token operator\">==#</span> <span class=\"token string\">'markdown'</span> | <span class=\"token keyword\">call</span> <span class=\"token function\">MarkdownFormat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> | <span class=\"token keyword\">endif</span> <span class=\"token comment\">\"7</span>\naugroup END</code></pre></div>\n<p>具体做一些解释：</p>\n<ol>\n<li><code>augroup</code> 相当于设置命名空间保证这个 autocmd 不影响其他的 autocmd</li>\n<li><code>autocmd!</code> 是清理当前 <code>augroup</code> 下的所有 <code>autocmd</code> 没有这命令会发现不知不觉每次保存的时候 autocorrect 会执行多次，具体什么原因我尚不清楚，毕这也是我第一次折腾这些命令，后续如果有更多了解会做更多记录</li>\n<li><code>slient !autocorrent --fix '%:p'</code>\n<ol>\n<li>执行外部的命令要加 <code>!</code></li>\n<li>添加 <code>slient</code> 是为了不要展示其执行的结果，我们只关心它执行了，不想看到它的返回内容</li>\n<li><code>'%:p'</code> 就是当前文件的绝对路径</li>\n</ol>\n</li>\n<li><code>winsaveview</code> 是保当前视图的一些信息，并且在重新加载文件后恢复，为的是不要让正在编辑的文件的视图位置、光标位置发生跳动提升体验</li>\n<li><code>slient edit</code> 是重新加载文件</li>\n<li><code>redraw!</code> 是刷当前视图</li>\n<li><code>if &#x26;filetype ==# 'markdown'</code> 是判断当前文件格式是否为 markdown 只有是 markdown 的时候才这行这个 autocmd</li>\n</ol>\n<h2 id=\"效果\" style=\"position:relative;\">效果<a href=\"#%E6%95%88%E6%9E%9C\" aria-label=\"效果 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>\n\t\t<video\n\t\t\tsrc=/videos/vim-autocorrect-integration.mp4\n\t\t\twidth=\"1200\"\n\t\t\theight=\"auto\"\n\t\t\tpreload=\"auto\"\n\t\t\tmuted=\"false\"\n\t\t\ttitle=\"/videos/vim-autocorrect-integration.mp4\"\n\t\t\t\n\t\t\tplaysinline\n\t\t\tcontrols\n\t\t\t\n\t\t></video>\n\t</p>","tableOfContents":"<ul>\n<li><a href=\"#%E9%97%AE%E9%A2%98\">问题</a></li>\n<li><a href=\"#%E6%80%9D%E8%B7%AF\">思路</a></li>\n<li><a href=\"#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\">具体实现方式</a></li>\n<li><a href=\"#%E6%95%88%E6%9E%9C\">效果</a></li>\n</ul>","frontmatter":{"title":"vim 里自动更新 markdown 格式","date":"January 22, 2022","tags":["vim","markdown","autocorrect"]},"excerpt":"问题 写 blog 的时候经常需要做中英文混排，然后这个混排为了美观需要在中和英文之间添加空格。现…"}},"pageContext":{"id":"1dd46bc1-353d-5a52-95f6-1572d359a34e"}},"staticQueryHashes":["26522286"],"slicesMap":{}}