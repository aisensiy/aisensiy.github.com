{"componentChunkName":"component---src-templates-blog-js","path":"/poj-1012","result":{"data":{"blog":{"id":"8535fa99-b553-56e1-8e77-015f4dbb0a59","html":"<p>又有一阵子不来写报告了，惭愧惭愧。现在赶紧补上。</p>\n<p>首先是经典的约瑟夫问题的解法</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;vector></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;cstring></span></span>\n\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/*\n *\n * 典型的约瑟夫问题\n * 约瑟夫问题是个有名的问题：N 个人围成一圈，从第一个开\n * 始报数，第 M 个将被杀掉，最后剩下一个，其余人都将被杀掉。\n * 例如 N=6，M=5，被杀掉的人的序号为 5，4，6，2，3。最后剩下 1 号。\n *\n * 这里采用一个递归解题 我们按照序号从 0 开始 m-1 个人退出\n * 假定第一个数到 m-1 的人退出后，那么将从下一个人重新计数\n * 我们假定这新的一轮开始的那个人序号为 0，那么在这一轮\n * 的 m-1 个人退出。\n * 那么，反过来，如果我们知道了第 i+1 轮退出的人在 i 轮一定是 j，\n * 我们可以通过 (j+m)%n 得知其在上一轮的位置\n *\n * @author: aisensiy(https://weibo.com/alistapart)\n */</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">jos</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> m<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">==</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token function\">jos</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> m<span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> n<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">;</span>\n    cin<span class=\"token operator\">>></span>n<span class=\"token operator\">>></span>m<span class=\"token punctuation\">;</span>\n    cout<span class=\"token operator\">&lt;&lt;</span><span class=\"token function\">jos</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">)</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">[</span><span class=\"token operator\">/</span>code<span class=\"token punctuation\">]</span>\n\n然后 poj <span class=\"token number\">1012</span> 是约瑟夫问题的一个变种，题目在这里<span class=\"token punctuation\">[</span>poj <span class=\"token number\">1012</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span>https<span class=\"token operator\">:</span><span class=\"token comment\">//poj.org/problem?id=1012)</span>\n\n<span class=\"token punctuation\">[</span>code lang<span class=\"token operator\">=</span><span class=\"token string\">\"cpp\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;iostream></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;vector></span></span>\n<span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;cstring></span></span>\n<span class=\"token comment\">/*\n * https://poj.org/problem?id=1012\n *\n * 约瑟夫问题的变种，采用完全的模拟会超时\n * 这里用到的一些技巧在下面的注释中会解答\n * 感谢 mabaochang 同学让我明白了本题最核心\n * 的 trick.\n *\n * @author: aisensiy(https://weibo.com/alistapart)\n */</span>\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> result<span class=\"token punctuation\">[</span><span class=\"token number\">14</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> killed<span class=\"token punctuation\">[</span><span class=\"token number\">14</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> cur<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        cur <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>cur <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> n<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>killed<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> cur<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">bool</span> <span class=\"token function\">work</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> m<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">memset</span><span class=\"token punctuation\">(</span>killed<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>killed<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> cur <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> dead <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> count <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 这里差不多就是最核心的 trick 了正常的约瑟夫问题这样的方式是不</span>\n        <span class=\"token comment\">// 能获取正确的 killed 的人的位置的，但是由于本题要求是后 k 个人</span>\n        <span class=\"token comment\">// 先被 killed，那么前 k 个人的位置是不应该被移动的（一旦移动了则说</span>\n        <span class=\"token comment\">// 明这时的 m 不满足条件，会 break），并且只要满足每次 killed 人在 k 之</span>\n        <span class=\"token comment\">// 后就行了，也不需要知道更具体的位置，采用这个公式就可以达到目的了</span>\n        cur <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>cur <span class=\"token operator\">+</span> m <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">%</span> count<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>cur <span class=\"token operator\">&lt;</span> n<span class=\"token operator\">/</span><span class=\"token number\">2</span> <span class=\"token operator\">&amp;&amp;</span> dead <span class=\"token operator\">&lt;</span> n<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>dead <span class=\"token operator\">>=</span> n<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        killed<span class=\"token punctuation\">[</span>cur<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        dead<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n        count<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> j<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 由于一共只有这么十几个数据，那么为了避免在线的重复计算</span>\n    <span class=\"token comment\">// 直接把所有结果算出来放到数组里就行了</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;=</span><span class=\"token number\">14</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>j<span class=\"token operator\">=</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token function\">work</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> i<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        result<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> j<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    cin<span class=\"token operator\">>></span>j<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        cout<span class=\"token operator\">&lt;&lt;</span>result<span class=\"token punctuation\">[</span>j<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">&lt;&lt;</span>endl<span class=\"token punctuation\">;</span>\n        cin<span class=\"token operator\">>></span>j<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","tableOfContents":"","frontmatter":{"title":"POJ 1012","date":"May 04, 2012","tags":["Joseph","约瑟夫问题"]},"excerpt":"又有一阵子不来写报告了，惭愧惭愧。现在赶紧补上。 首先是经典的约瑟夫问题的解法"}},"pageContext":{"id":"8535fa99-b553-56e1-8e77-015f4dbb0a59"}},"staticQueryHashes":["4202924991"]}