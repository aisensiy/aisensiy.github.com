{
    "componentChunkName": "component---src-templates-blog-js",
    "path": "/2021/02/20/rest-vs-graphql/",
    "result": {"data":{"blog":{"id":"1af97849-15b1-56f1-bee2-fea32ea44f5c","html":"<p>考虑到目前 REST API 层和前端对接起来不是那么顺滑，于是有去找解决方案了，找来找去感觉也就是切 GraphQL 了，这次又来看 GraphQL 感觉它比上次看要香了。好好总觉了一些东西出来。</p>\n<h2 id=\"为什么之前对-graphql-不感兴趣\" style=\"position:relative;\">为什么之前对 GraphQL 不感兴趣<a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B9%8B%E5%89%8D%E5%AF%B9-graphql-%E4%B8%8D%E6%84%9F%E5%85%B4%E8%B6%A3\" aria-label=\"为什么之前对 graphql 不感兴趣 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>之前有注意到 GraphQL，毕竟也都好几年了呢，但当时一方面是没有对它有比较充分的理解，没有真切的感受到它的好处，另一方面是其存在诸多对于 REST 的一些误解。</p>\n<h3 id=\"认为-rest-的资源是独立的\" style=\"position:relative;\">认为 REST 的资源是独立的<a href=\"#%E8%AE%A4%E4%B8%BA-rest-%E7%9A%84%E8%B5%84%E6%BA%90%E6%98%AF%E7%8B%AC%E7%AB%8B%E7%9A%84\" aria-label=\"认为 rest 的资源是独立的 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><img src=\"https://images-1300693298.cos.ap-beijing.myqcloud.com/20210216231615.png\" alt=\"\"></p>\n<p>这是我从一个介绍 GraphQL 的材料里找到的例子，例子中提到如果用户想要获取一个 book 列表，每个 book 中还要包含 author 的信息，就很容易出现 N+1 个请求的问题，效率非常低下。如果这也是为什么要有 GraphQL 的原因之一的话，那其实没必要有 GraphQL...</p>\n<p>REST 也没有这么死板吧。实际上在返回的每一个 book 中包含 author 信息是非常自然的事情：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GET /books\n\n{\n  \"data\": [\n    {\n      \"id\": \"1\",\n      \"title\": \"how to graphql\",\n      \"description\": \"bla\",\n      \"author\": {\n        \"id\": \"x\",\n        \"name\": \"abc\",\n        \"avatar\": \"http://avatar.com\"\n      }\n    }\n    ...\n  ]\n}</code></pre></div>\n<p>自我一篇很古老的<a href=\"/some-tips-for-ddd\">文章</a>里就提到了，<code>GET</code> 请求获取的是「读模型」，应该按照调用方的需求合理的展示相关的数据，以方便调用方的使用。如果像这里说的方法就是大家使用 REST 的方式的话，我觉得前端早就疯了。实际上，这种灵活的聚合展示早就是家常便饭了呢，当然，从标准化的角度来说，这却是也是一个巨大的问题。</p>\n<h3 id=\"过度担忧-overfetching\" style=\"position:relative;\">过度担忧 overfetching<a href=\"#%E8%BF%87%E5%BA%A6%E6%8B%85%E5%BF%A7-overfetching\" aria-label=\"过度担忧 overfetching permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><a href=\"https://martinfowler.com/bliki/TolerantReader.html\">TolerantReader</a> 有提到，如果你对于一个请求只关心其一部分信息，那就只处理那部分就好，至于其他的字段，请自行忽略。对于这些额外的字段所带来的额外的数据其实是完全不需要担心的：</p>\n<ol>\n<li>REST 请求所获取的资源通常都是区分 data 和 data-item 的。\n<ul>\n<li>data 是一个全量的信息，比如上午提到的一个完整的 book 信息，包含其详细的描述、目录、甚至热门评论，其所拥有的具体字段完全是和调用方探讨确认的，通常用于详情页面的展示</li>\n<li>data-item 通常是一个资源的 summary 通常用于列表的展示</li>\n</ul>\n这两种类型的区分本来就考虑了 overfetching 的问题：有些字段字段获取成本比较高，在列表里获取很容易产生 N+1 的问题，因此就只在 data 中出现，而不会出现在 data-item 中。在有了这个原则之后，额外那些字段其实不会对性能有什么非常大的影响。</li>\n<li>每次返回的结构一致更容易做缓存，一次获取长期拥有，其实没那么大成本</li>\n</ol>\n<h2 id=\"目前-rest-的一些问题\" style=\"position:relative;\">目前 REST 的一些问题<a href=\"#%E7%9B%AE%E5%89%8D-rest-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98\" aria-label=\"目前 rest 的一些问题 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>不过 REST 也不是没有问题，在 <a href=\"/rest-practice\">REST 的一些实践心得</a> 也做了一些吐槽。总结来说就是这么几点：</p>\n<ol>\n<li>也有类似于 <a href=\"https://jsonapi.org/\">jsonapi</a> 的东西出现，但不算公认的标准，也没有形成什么很好的支持</li>\n<li>没有大厂支持，依靠社区进展比较缓慢，OpenAPI 的众多工具都有奇奇怪怪的小问题</li>\n<li>对 websocket 没有很好的支持</li>\n<li>没有考虑 HATEOAS 的弊端，这里我直接意译 <a href=\"https://hasura.io/blog/rest-view-of-graphql/\">A REST View of GraphQL</a> 的观点，讲的太好了：</li>\n</ol>\n<blockquote>\n<p>HATEOAS 在用户是最终用户的时候比较有意义，可以支持用户像是在浏览器里面做探索，每个页面有链接指引用户。即使页面发生了变化，只要链接都在就能够支持用户。</p>\n</blockquote>\n<blockquote>\n<p>可惜对于 API Client 来说，只需要一次性去调用具体某一个接口的，如果每次都从根源去探索 API 效率是非常低下的。这种情况下类似于 OpenAPI 所生成的 SDK 是更方便的。</p>\n</blockquote>\n<blockquote>\n<p>从目前的交互模式来看，前端就是这么一个 API Client 而已，HATEOAS 对其并没有什么意义。任何 API schema 的修改都可能导致 API Client 的崩溃。</p>\n</blockquote>\n<h2 id=\"采用-graphql-的一些好处\" style=\"position:relative;\">采用 GraphQL 的一些好处<a href=\"#%E9%87%87%E7%94%A8-graphql-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A5%BD%E5%A4%84\" aria-label=\"采用 graphql 的一些好处 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ol>\n<li>Graph 的 metal model 非常适合做「读」模型的标准化</li>\n<li>强大的生态，首先是 facebook 提出的，后面相当多的公司都有跟进（Github、Airbnb、Netflix）</li>\n<li>工具链比较健全：\n<ol>\n<li>GraphiQL, GraphQL Playground 这样类似于 postman 的测试调用工具</li>\n<li>Apollo 这样做前后端继承框架开发的公司，在前后端都做的不错</li>\n<li>对微服务的支持，<a href=\"https://www.apollographql.com/docs/federation/federation-spec/\">Apollo Federation</a></li>\n<li><a href=\"https://github.com/pipedrive/graphql-schema-registry\">schema-registry</a> 甚至有这种 schema 变更追溯的东西，REST 这边想都不敢想</li>\n</ol>\n</li>\n<li>有 <code>subscription</code> 的概念，将长链接的情况也考虑在内了</li>\n</ol>\n<p>整体来说，我觉得 GraphQL 是一个工具更健全，规范更完善，生命力更持久的体系。却是克服了 rest 中的一些问题，后面会开始尝试用 GraphQL 对原有 API 做一层封装看看效果。</p>\n<h2 id=\"参考资料\" style=\"position:relative;\">参考资料<a href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\" aria-label=\"参考资料 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ol>\n<li><a href=\"https://hasura.io/blog/rest-view-of-graphql/\">A REST View of GraphQL</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=JsvElHDuqoA\">Shipping 'Belonging' with GraphQL &#x26; Apollo at Airbnb (Adam Neary)</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=zWhVAN4Tg6M\">GraphQL: The Mental Model — Dhaivat Pandya</a></li>\n<li><a href=\"https://apollographql.com/\">Apollo GraphQL</a></li>\n<li><a href=\"https://www.apollographql.com/docs/federation/federation-spec/\">Apollo Federation</a></li>\n<li><a href=\"https://github.com/pipedrive/graphql-schema-registry\">schema-registry</a></li>\n</ol>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B9%8B%E5%89%8D%E5%AF%B9-graphql-%E4%B8%8D%E6%84%9F%E5%85%B4%E8%B6%A3\">为什么之前对 GraphQL 不感兴趣</a></p>\n<ul>\n<li><a href=\"#%E8%AE%A4%E4%B8%BA-rest-%E7%9A%84%E8%B5%84%E6%BA%90%E6%98%AF%E7%8B%AC%E7%AB%8B%E7%9A%84\">认为 REST 的资源是独立的</a></li>\n<li><a href=\"#%E8%BF%87%E5%BA%A6%E6%8B%85%E5%BF%A7-overfetching\">过度担忧 overfetching</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E7%9B%AE%E5%89%8D-rest-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98\">目前 REST 的一些问题</a></p>\n</li>\n<li>\n<p><a href=\"#%E9%87%87%E7%94%A8-graphql-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A5%BD%E5%A4%84\">采用 GraphQL 的一些好处</a></p>\n</li>\n<li>\n<p><a href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\">参考资料</a></p>\n</li>\n</ul>","frontmatter":{"title":"REST vs GraphQL","date":"February 20, 2021","tags":["web","rest","graphql"]},"excerpt":"考虑到目前 REST API 层和前端对接起来不是那么顺滑，于是有去找解决方案了，找来找去感觉也就…"}},"pageContext":{"id":"1af97849-15b1-56f1-bee2-fea32ea44f5c"}},
    "staticQueryHashes": ["4202924991"]}