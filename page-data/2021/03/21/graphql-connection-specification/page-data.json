{"componentChunkName":"component---src-templates-blog-js","path":"/2021/03/21/graphql-connection-specification/","result":{"data":{"blog":{"id":"44325dfc-0063-5ab4-a718-57de56676794","html":"<p>GraphQL 之前已经夸了不少了，见 <a href=\"/rest-vs-graphql\">REST vs GraphQL</a>，确实在<strong>标准化</strong>方面远超 REST 了，这也是我想要切换到 GraphQL 的一大原因。不过 GraphQL 甚至连分页也提了一个标准，挺有意思的，看了看他们的 <a href=\"https://relay.dev/graphql/connections.htm\">GraphQL Cursor Connections Specification</a> ，想做一些自己理解的记录。</p>\n<p>这样标准化的好处就是可以让前端也有一个类似的组件去处理分页，让这部分的工作就直接通过这个公共组件给覆盖了。想象一下，如果有更多的东西可以以这种方式形成标准，那相当于不少工作也就可以复用了呢？</p>\n<p>分页这个东西虽然没有这样子如此明确的标准，但其实从各种文档、书籍、博客里也都逐渐形成了类似的标准了呢，毕竟这已经是一个非常古老的需求了。这里我就以最简单的方式介绍目前两种针对不同场景的分页风格，更多的信息可以从下文的参考中找的到。</p>\n<h2 id=\"两种分页方式\" style=\"position:relative;\">两种分页方式<a href=\"#%E4%B8%A4%E7%A7%8D%E5%88%86%E9%A1%B5%E6%96%B9%E5%BC%8F\" aria-label=\"两种分页方式 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"limit-offset-分页\" style=\"position:relative;\">limit offset 分页<a href=\"#limit-offset-%E5%88%86%E9%A1%B5\" aria-label=\"limit offset 分页 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>对于记录不多并且增删不频繁的场景，<code class=\"language-text\">limit-offset</code> 的方式基本是最健全的分页了。通过从数据库的 <code class=\"language-text\">select * from xx limit xxx offset xxx</code> 配合 <code class=\"language-text\">select count(*) from xx</code> 可以获取非常全面的分页信息以及动作：</p>\n<ul>\n<li>一共多少页</li>\n<li>当前是第几页</li>\n<li>去下一页</li>\n<li>去上一页</li>\n<li>去第一页</li>\n<li>去最后一页</li>\n</ul>\n<p>但缺点也很明确：offset 这个语法对数据记录多的场景不友好，查询速度会明显下降，同时对快速变化的数据也不友好，很容易丢查询数据。</p>\n<h3 id=\"cursor-limit-分页\" style=\"position:relative;\">cursor limit 分页<a href=\"#cursor-limit-%E5%88%86%E9%A1%B5\" aria-label=\"cursor limit 分页 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">cursor-limit</code> 分页则是以类似于 <code class=\"language-text\">select * from xxx where cursor &lt; xxx order by cursor limit xx</code> 的方式获取相对于 <code class=\"language-text\">cursor</code> 的记录。相对于 <code class=\"language-text\">limit-offset</code> 的方式会<strong>很难</strong>获取以下信息：</p>\n<ul>\n<li>一共多少页</li>\n<li>当前是第几页</li>\n<li>去最后一页</li>\n</ul>\n<h2 id=\"graphql-cursor-connection-标准的一些细节\" style=\"position:relative;\">graphql cursor connection 标准的一些细节<a href=\"#graphql-cursor-connection-%E6%A0%87%E5%87%86%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82\" aria-label=\"graphql cursor connection 标准的一些细节 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"保留字段\" style=\"position:relative;\">保留字段<a href=\"#%E4%BF%9D%E7%95%99%E5%AD%97%E6%AE%B5\" aria-label=\"保留字段 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>GraphQL 定义凡事以 <code class=\"language-text\">Connection</code> 结尾的结构都遵循 <code class=\"language-text\">Cursor Connection</code> 的数据结构，并且名为 <code class=\"language-text\">PageInfo</code> 的东西都是 <code class=\"language-text\">Cursor Connection</code> 下的 <code class=\"language-text\">PageInfo</code> 结构。</p>\n<h3 id=\"查询参数\" style=\"position:relative;\">查询参数<a href=\"#%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0\" aria-label=\"查询参数 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><code class=\"language-text\">first after</code> 与 <code class=\"language-text\">last before</code> 必须分组出现，也就是说可以是以下几种形式:</p>\n<ol>\n<li><code class=\"language-text\">articles(first: Int!, after: String!)</code></li>\n<li><code class=\"language-text\">articles(last: Int!, before: String!)</code></li>\n<li><code class=\"language-text\">articles(first: Int, after: String, last: Int, before: String)</code></li>\n</ol>\n<p>第三种就是同时支持正序和倒序查找，也就是支持向前翻页。</p>\n<h3 id=\"具体算法和实施\" style=\"position:relative;\">具体算法和实施<a href=\"#%E5%85%B7%E4%BD%93%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E6%96%BD\" aria-label=\"具体算法和实施 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>这里就按照 <code class=\"language-text\">first after</code> 为例子做介绍了，<code class=\"language-text\">last before</code> 都是反过来的，就不复读机了：</p>\n<ol>\n<li>首先查询的时候按照 <code class=\"language-text\">after + 1</code> 去查询，如果返回的个数为 <code class=\"language-text\">after + 1</code> 那就意味着有下一页（hasNextPage），否则就是没有。</li>\n<li>如果还要考虑判断 <code class=\"language-text\">hasPreviousPage</code> 那意味着每次都多一个查询 <code class=\"language-text\">select * from xxx where cursor &lt; #{startCursor} limit 1</code>，如果有结果就意味着返回 <code class=\"language-text\">true</code>。</li>\n<li>当然对很多自动加载下一页的场景就不考虑往前翻页了，这个就直接全部 <code class=\"language-text\">false</code> 就好了。</li>\n</ol>\n<h2 id=\"最后\" style=\"position:relative;\">最后<a href=\"#%E6%9C%80%E5%90%8E\" aria-label=\"最后 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>最近把 <a href=\"https://github.com/gothinkster/spring-boot-realworld-example-app\">realworld-example-app</a> 改写的差不多了，已经同时支持 GraphQL 和 REST 了，其中 GraphQL 部分的分页也是按照 <code class=\"language-text\">cursor connection</code> 的形式做的，然后我需要找个前端的 RealWorld 项目去对接下，看看我这个分页折腾的对不对了。</p>\n<h2 id=\"参考\" style=\"position:relative;\">参考<a href=\"#%E5%8F%82%E8%80%83\" aria-label=\"参考 permalink\" class=\"custom-class after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li><a href=\"https://medium.com/swlh/how-to-implement-cursor-pagination-like-a-pro-513140b65f32\">How to Implement Cursor Pagination Like a Pro</a></li>\n<li><a href=\"https://uxdesign.cc/why-facebook-says-cursor-pagination-is-the-greatest-d6b98d86b6c0\">Is offset pagination dead? Why cursor pagination is taking over</a></li>\n<li><a href=\"https://graphql.org/learn/pagination/\">GraphQL Pagination</a></li>\n</ul>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%E4%B8%A4%E7%A7%8D%E5%88%86%E9%A1%B5%E6%96%B9%E5%BC%8F\">两种分页方式</a></p>\n<ul>\n<li><a href=\"#limit-offset-%E5%88%86%E9%A1%B5\">limit offset 分页</a></li>\n<li><a href=\"#cursor-limit-%E5%88%86%E9%A1%B5\">cursor limit 分页</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#graphql-cursor-connection-%E6%A0%87%E5%87%86%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82\">graphql cursor connection 标准的一些细节</a></p>\n<ul>\n<li><a href=\"#%E4%BF%9D%E7%95%99%E5%AD%97%E6%AE%B5\">保留字段</a></li>\n<li><a href=\"#%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0\">查询参数</a></li>\n<li><a href=\"#%E5%85%B7%E4%BD%93%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E6%96%BD\">具体算法和实施</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E6%9C%80%E5%90%8E\">最后</a></p>\n</li>\n<li>\n<p><a href=\"#%E5%8F%82%E8%80%83\">参考</a></p>\n</li>\n</ul>","frontmatter":{"title":"GraphQL Cursor 分页","date":"March 21, 2021"}}},"pageContext":{"id":"44325dfc-0063-5ab4-a718-57de56676794"}},"staticQueryHashes":[]}